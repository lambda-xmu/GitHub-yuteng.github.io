<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/ironman-draw.png">
    <!-- Place this tag in your head or just before your close body tag. -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <title>
        
          面试问题总结 - 于腾 | Blog
        
    </title>

    <link rel="canonical" href="https://github-yuteng.github.io/article/面试问题/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS --> 
    <link rel="stylesheet" href="/css/beantech.min.css">

    <link rel="stylesheet" href="/css/donate.css">
    
    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="/css/highlight.css">

    <link rel="stylesheet" href="/css/widget.css">

    <link rel="stylesheet" href="/css/rocket.css">

    <link rel="stylesheet" href="/css/signature.css">

    <link rel="stylesheet" href="/css/toc.css">

    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">
	<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        
            background-image: url('/img/article_header/article_bg.jpg')
            /*post*/
        
    }
    
</style>

<header class="intro-header" >
    <!-- Signature -->
    <div id="signature">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                
                    <div class="post-heading">
                        <div class="tags">
                            
                              <a class="tag" href="/tags/#面试" title="面试">面试</a>
                            
                        </div>
                        <h1>面试问题总结</h1>
                        <h2 class="subheading"></h2>
                        <span class="meta">
                            Posted by 于腾 on
                            2019-05-08
                        </span>
                    </div>
                


                </div>
            </div>
        </div>
    </div>
</header>

	
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">所爱隔山海</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                        <li>
                            <a href="/about/">至此至终</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/archive/">Archives</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    <!-- Modify by Yu-Hsuan Yen -->

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <h2 id="1-equals-amp-hashcode">1、equals() &amp; hashCode()</h2>
<p><strong>在重写equals方法的同时，必须重写hashCode方法。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;<span class="comment">//该方法返回一个int类型的数值，并且是本地方法</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><strong>equals 如果不重写底层为 == 比较的为对象的地址。</strong></p>
</li>
<li>
<p><strong>重写了 hashcode() 两个相同对象的 hashcode 才相等。</strong></p>
</li>
</ul>
<hr>
<p><strong>对于两个对象:</strong></p>
<ul>
<li>1、两个不同的对象可能会生成相同 Hashcode 值（Hashcode值相等，equals方法结果未知）</li>
<li>2、两个对象的 Hashcode 值不同，必定是两个不同的对象，equals方法结果必定为false。</li>
<li>3、如果调用 equals 方法得到的结果为 true，则两个对象的 Hashcode 值必定相等；</li>
<li>4、如果调用 equals 方法得到的结果为 false，则两个对象的 Hashcode 值不一定不同；</li>
</ul>
<p><strong>配合基于散列的集合一起正常运行，散列集合包括HashSet、HashMap以及HashTable。</strong><br>
<strong><code>如果不重写 hashCode 方法，无法使用 Map，Set 等集合。（实体类作为 Key，失效）</code></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 重写了 hashcode() 两个对象的 hashcode 才相等。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        People p1 = <span class="keyword">new</span> People(<span class="string">"Jack"</span>, <span class="number">12</span>);</span><br><span class="line">        System.out.println(p1.hashCode());<span class="comment">//71329710</span></span><br><span class="line"></span><br><span class="line">        People p2 = <span class="keyword">new</span> People(<span class="string">"Jack"</span>, <span class="number">12</span>);</span><br><span class="line">        System.out.println(p2.hashCode());<span class="comment">//71329710</span></span><br><span class="line"></span><br><span class="line">        HashMap&lt;People, Integer&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        hashMap.put(p1, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//TODO 在设计hashCode方法和equals方法的时候，如果对象中的数据易变</span></span><br><span class="line">        <span class="comment">//TODO 则最好在equals方法和hashCode方法中不要依赖于该字段。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// p1.setAge(1);//如果更改了字段值，hashcode值将更改</span></span><br><span class="line">        <span class="comment">// System.out.println(p1.hashCode());//71329699</span></span><br><span class="line"></span><br><span class="line">        System.out.println(hashMap.get(p1));<span class="comment">//</span></span><br><span class="line">        System.out.println(hashMap.get(p2));<span class="comment">//如果不重写 则为 null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * equals 如果不重写底层为 == 比较的为 对象地址 则为 false</span></span><br><span class="line"><span class="comment">         * public boolean equals(Object obj) &#123;</span></span><br><span class="line"><span class="comment">         *      return (this == obj);</span></span><br><span class="line"><span class="comment">         * &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(p1.equals(p2));<span class="comment">// 期望值为 true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        People people = (People) o;</span><br><span class="line">        <span class="keyword">return</span> age == people.age &amp;&amp;</span><br><span class="line">                Objects.equals(name, people.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="2-equals-amp">2、equals &amp; ==</h2>
<p><strong>摘自《Java编程思想》一书中的原话：</strong></p>
<p><strong><code>“关系操作符生成的是一个boolean结果，它们计算的是操作数的值之间的关系”。</code></strong></p>
<hr>
<p><strong>== 对于基本数据类型 和 String，是直接比较的值。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i1 = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">int</span> i2 = <span class="number">12</span>;</span><br><span class="line">System.out.println(i1 == i2);<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">String s1 = <span class="string">"hello"</span>;</span><br><span class="line">String s2 = <span class="string">"hello"</span>;</span><br><span class="line">System.out.println(s1 == s2);<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"hello"</span>);</span><br><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">"hello"</span>);</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"hello"</span>);</span><br><span class="line">System.out.println(<span class="string">"-&gt;:"</span> + (str1 == str2));<span class="comment">// -&gt;:false</span></span><br><span class="line">System.out.println(<span class="string">"=&gt;:"</span> + str1.equals(str2));<span class="comment">// =&gt;:true</span></span><br><span class="line"><span class="comment">//TODO String类对equals方法进行了重写，用来比较指向的字符串对象所存储的字符串是否相等。</span></span><br><span class="line"></span><br><span class="line">str1 = str;</span><br><span class="line">str2 = str;</span><br><span class="line">System.out.println(<span class="string">"-&gt;:"</span> + (str1 == str2));<span class="comment">// -&gt;:true</span></span><br></pre></td></tr></table></figure>
<hr>
<p><strong>== 对于引用类型，是直接比较的两个对象的堆内存地址，如果相等，则说明这两个引用实际是指向同一个对象地址。</strong></p>
<p><strong>Integer 在常量池中的存储范围为[-128,127]</strong></p>
<ul>
<li>127在这范围内，因此是直接存储于常量池的，而128不在这范围内，所以会在堆内存中创建一个新的对象来保存这个值，所以 i5，i6 分别指向了两个不同的对象地址，故而导致了不相等。</li>
</ul>
<p><strong><code>Integer 源码</code></strong>  👇</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)&#123;</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Integer i3 = <span class="number">127</span>;</span><br><span class="line">Integer i4 = <span class="number">127</span>;</span><br><span class="line"><span class="comment">//It's best to use equals() to compare</span></span><br><span class="line">System.out.println(i3 == i4);<span class="comment">// true</span></span><br><span class="line">System.out.println(i3.equals(i4));<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">Integer i5 = <span class="number">128</span>;</span><br><span class="line">Integer i6 = <span class="number">128</span>;</span><br><span class="line"><span class="comment">//It's best to use equals() to compare</span></span><br><span class="line">System.out.println(i5 == i6);<span class="comment">// -----&gt; false</span></span><br><span class="line">System.out.println(i5.equals(i6));<span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id=""></h3>
<p>1）<strong>对于==，比较的是值是否相等</strong></p>
<ul>
<li>
<p>如果作用于基本数据类型的变量，则直接比较其存储的 “值”是否相等；</p>
</li>
<li>
<p>如果作用于引用类型的变量，则比较的是所指向的对象的地址。</p>
</li>
</ul>
<p>2）<strong>对于equals方法，所有类从Object类中继承equals方法，比较的是否是同一个对象。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>注意：equals() 方法本身和 == 没有区别，但不能作用于基本数据类型的变量（可以为包装类型，比较值）；</p>
</li>
<li>
<p>如果没有对 equals 方法进行重写，则比较的是引用类型的变量所指向的对象的地址，；</p>
</li>
<li>
<p>诸如String、Date等类对equals方法进行了重写的话，比较的是所指向的对象的内容。</p>
</li>
</ul>
<hr>
<hr>
<h2 id="3-hashmap">3、HashMap</h2>
<p><strong>HashMap实现了Map接口，Map接口对键值对进行映射。Map中不允许出现重复的键（Key）。</strong></p>
<ul>
<li><strong>在 JDK1.6，JDK1.7 中，HashMap采用 <code>哈希桶数组(位桶)+链表</code>实现，即使用链表处理冲突。头插法</strong>
<ul>
<li>当位于一个桶中的元素较多(链表过长)，即 Hash 值相等的元素较多时，通过key值依次查找的效率较低。</li>
</ul>
</li>
<li><strong>在  JDK1.8 中，HashMap采用 <code>哈希桶数组(位桶)+链表+红黑树</code>实现，当链表长度超过阈值 (8) 时，将链表转换为红黑树。</strong></li>
</ul>
<hr>
<h3 id="jdk-18-hashmap-实现原理">JDK 1.8 HashMap 实现原理</h3>
<p><strong>首先有一个 哈希桶数组(位桶)，当添加一个元素（key-value）时，首先计算元素 Key 的 Hash 值，以此确定插入数组中的位置，但是可能存在相同 Hash值的元素已经被放在数组同一位置了，这时就添加到同一 Hash 值的元素的后面，他们在数组的同一位置，但是形成了链表，同一各链表上的 Hash 值是相同的，所以说数组存放的是链表。但是当链表长度太长时，JDK 1.8 链表就转换为红黑树，大大提高了查找的效率。</strong></p>
<ul>
<li><strong>hashCode方法的存在是为了减少equals方法的调用次数，从而提高程序效率。</strong></li>
</ul>
<hr>
<img src="https://i.loli.net/2019/07/17/5d2e931bac9a719213.png" alt="1.png" title="1.png">
<h4 id="存储结构-字段">存储结构-字段</h4>
<p><strong>HashMap类中有一个非常重要的字段，就是 Node&lt;K,V&gt;[] table，即 哈希桶数组；</strong></p>
<p><strong>Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Node是单向链表，它实现了Map.Entry接口 存储着key-value</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash; <span class="comment">//保存该桶的hash值</span></span><br><span class="line">    <span class="keyword">final</span> K key; <span class="comment">//不可变的key</span></span><br><span class="line">    V value; <span class="comment">//指向一个数据的指针</span></span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="hash-冲突">Hash 冲突</h4>
<p><strong>有时候两个 key 的 hashCode 可能会定位到一个桶中，这时就发生了hash冲突，如果HashMap的 Hash 算法越散列，那么发生Hash 冲突的概率越低。如果数组越大，那么发生 Hash 冲突的概率也会越低，但是数组越大带来的空间开销越多，但是遍历速度越快，这就要在空间和时间上进行权衡，这就要看看 HashMap 的扩容机制。</strong></p>
<hr>
<h4 id="扩容机制">扩容机制</h4>
<p><strong>扩容机制几个比较重要的字段</strong></p>
<ul>
<li>
<p>static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16  <code>默认为16个桶</code></p>
</li>
<li>
<p>static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; //<code>默认桶最多有2^30个,并且必须是 2的幂</code></p>
</li>
<li>
<p>static final float DEFAULT_LOAD_FACTOR = 0.75f; //<code>默认负载因子是0.75</code></p>
</li>
<li>
<p>int threshold; //<code>能容纳最多key_value对的个数</code></p>
</li>
<li>
<p>transient int size; //<code>一共有 key-value对 个数</code></p>
</li>
<li>
<p>transient int modCount; //<code>记录是发生内部结构变化的次数 put不算发生结构变化</code></p>
</li>
</ul>
<p><strong>threshold = 负载因子 * length，也就是说数组长度固定以后， 如果负载因子越大，所能容纳的元素个数越多，如果超过这个值（threshold ）就会进行扩容(默认是扩容为原来的2倍)，0.75这个值是权衡过空间和时间得出的。(这个值可以大于1)</strong></p>
<p><strong>因为 HashMap 扩容每次都是扩容为原来的2倍，所以 length 总是2的次方，这是非常规的设置，常规设置是把桶的大小设置为素数，因为<code>素数发生hash冲突的概率要小于合数</code>，比如HashTable的默认值设置为11，就是桶的大小为素数的应用(HashTable扩容后不能保证是素数)。HashMap采用这种设置是为了在取模和扩容的时候做出优化。</strong></p>
<p><strong>hashMap是通过key的hashCode的高16位和低16位异或后和桶的数量取模得到索引位置。如下：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">// h = key.hashCode() 为第一步 取hashCode值</span></span><br><span class="line">    <span class="comment">// h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>在扩容的时候，如果length每次是 2^n，那么重新计算出来的索引只有两种情况，一种是 old 索引+16，另一种是索引不变，所以就不需要每次都重新计算索引。</strong></p>
<hr>
<h4 id="hashmap的put方法实现">HashMap的put方法实现</h4>
<p><strong>实现思路：</strong></p>
<ul>
<li>
<p><strong>1.判断键值对数组 Node&lt;K,V&gt;[] table 是否为空。</strong></p>
</li>
<li>
<p><strong>2.判断 table[i] 处是否插入过值</strong>。</p>
</li>
<li>
<p><strong>3.判断链表长度是否大于8，小于挂在链表最后，如果大于就转换为红黑二叉树，并插入树中</strong>。</p>
</li>
<li>
<p><strong>4.判断key是否和原有key相同，如果相同就覆盖原有key的value，并返回原有value。(旧值)</strong></p>
</li>
<li>
<p><strong>5.如果key不相同，就插入一个key，<code>记录结构变化一次</code>（modCount）。</strong></p>
</li>
</ul>
<p>通俗来说：Java中的hashCode方法就是根据一定的规则将与对象相关的信息（比如对象的存储地址，对象的字段等）映射成一个数值，这个数值称作为散列值(HashCode值)。 有些朋友误以为默认情况下，hashCode返回的就是对象的存储地址，事实上这种看法是不全面的，确实有些JVM在实现时是直接返回对象的存储地址，但是大多时候并不是这样，只能说可能存储地址有一定关联。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Implements Map.put and related methods</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> onlyIfAbsent if true, don't change existing value</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,<span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">//判断table是否为空，如果是空的就创建一个table，并获取他的长度</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//如果计算出来的索引位置之前没有放过数据，就直接放入</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//进入这里说明索引位置已经放入过数据了</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//判断put的数据和之前的数据是否重复</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            <span class="comment">//key的地址或key的equals()只要有一个相等就认为key重复了，就直接覆盖原来key的value</span></span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">//判断是否是红黑树，如果是红黑树就直接插入树中</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果不是红黑树，就遍历每个节点，判断链表长度是否大于8，如果大于就转换为红黑树</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//判断索引每个元素的key是否和可要插入的key相同，如果相同就直接覆盖</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果e不是null，说明没有迭代到最后就跳出了循环，说明链表中有相同的key</span></span><br><span class="line">        <span class="comment">//因此只需要将value覆盖，并将oldValue返回即可</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;<span class="comment">//返回存在的Value值 旧值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//说明没有key相同，因此要插入一个key-value，并记录内部结构变化次数</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)<span class="comment">//大于了 threshold</span></span><br><span class="line">        resize();<span class="comment">//扩容两倍  </span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="hashmap的get方法实现">HashMap的get方法实现</h4>
<p><strong>实现思路：</strong></p>
<ul>
<li>
<p><strong>1.判断表或key是否是null，如果是直接返回null</strong>。</p>
</li>
<li>
<p><strong>2.判断索引处第一个key与传入key是否相等，如果相等直接返回。</strong></p>
</li>
<li>
<p><strong>3.如果不相等，判断链表是否是红黑二叉树，如果是，直接从树中取值。</strong></p>
</li>
<li>
<p><strong>4.如果不是树，就遍历链表查找。</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">//如果表不是空的，并且要查找索引处有值，就判断位于第一个的key是否是要查找的key</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="comment">//如果是，就直接返回</span></span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">//如果不是就判断链表是否是红黑二叉树，如果是，就从树中取值</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">//如果不是树，就遍历链表</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="4-hashset">4、HashSet</h2>
<p><strong>HashSet 实现了Set接口，底层是HashMap</strong>。</p>
<p><strong>HashSet 的方法，也是借助HashMap的方法来实现的。</strong></p>
<ul>
<li>HashSet 实现了Set接口，它不允许集合中出现重复元素。(仅存储对象)</li>
<li>不能保证元素的顺序，元素是无序的。</li>
<li>集合元素值允许为null。</li>
<li>HashSet不是同步的，需要外部保持线程之间的同步问题。</li>
<li>将对象存储在HashSet之前，<code>要确保重写 equals() 方法 和 hashCode() 方法</code> ，这样才能比较对象的值是否相等，确保集合中没有储存相同的对象。</li>
</ul>
<h3 id="hashset-元素不重复">HashSet 元素不重复</h3>
<p><strong>实现了 Set 接口：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>
<p><strong>类中 map 和 PARENT 的定义：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;<span class="comment">//map集合，HashSet存放元素的容器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();<span class="comment">//map，中键对应的value值</span></span><br></pre></td></tr></table></figure>
<p><strong>构造方法:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无参构造方法，完成map的创建</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指定集合转化为HashSet, 完成map的创建</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">   map = <span class="keyword">new</span> HashMap&lt;&gt;(Math.max((<span class="keyword">int</span>) (c.size()/.<span class="number">75f</span>) + <span class="number">1</span>, <span class="number">16</span>));</span><br><span class="line">   addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指定初始化大小，和负载因子</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指定初始化大小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指定初始化大小和负载因子，dummy 无实际意义</span></span><br><span class="line">HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>源码 👉 HashSet 类中的add()方法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>来到了 👉 HashMap 的 put()方法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> HashSet&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"> set.add(<span class="string">"1"</span>);</span><br><span class="line"> set.add(<span class="string">"1"</span>);</span><br><span class="line"> set.add(<span class="string">"2"</span>);</span><br><span class="line"> set.add(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">Iterator&lt;String&gt; iterator = set.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">    String next = iterator.next();</span><br><span class="line">    System.out.println(next);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* null</span></span><br><span class="line"><span class="comment">* 1</span></span><br><span class="line"><span class="comment">* 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="5-concurrenthashmap">5、ConcurrentHashMap</h2>
<p><strong>if (<code>key == null || value == null</code>) throw new <code>NullPointerException();</code></strong></p>
<ul>
<li><strong>key-value都不可为空！</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br></pre></td></tr></table></figure>
<p><strong>ConcurrentHashMap 可以支持并发的读写</strong>。</p>
<img src="https://i.loli.net/2019/07/17/5d2ece546df0066415.png" alt="1.png" title="1.png">
<p><strong>HashMap：非线程安全</strong>，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。</p>
<ul>
<li>HashMap 做put 操作的时候，假如A线程和B线程同时对同一个数组位置调用addEntry，两个线程会同时得到现在的头结点，然后A写入新的头结点之后，B也写入新的头结点，那B的写入操作就会覆盖A的写入操作造成A的写入操作丢失。同理，当多线程对同一数组位置进行remove操作时也会产生覆盖。因此如果不进行额外的外同步操作，HashMap 是非线程安全的。样必然导致效率低下，而且竞争越激烈，效率越低下。严重情况，<strong>两个线程使用HashMap进行put操作会引起死循环(比如put的两个对象 引起扩容，可能出现同时在同一数组下用链表表示，结果在get时会出现死循环)，导致CPU利用率接近100%</strong>。</li>
</ul>
<p><strong>HashTable：遗留类，线程安全。</strong> 很多映射的常用功能与HashMap类似，不同的是它承自Dictionary类，并且是线程安全的，任一时间只有一个线程能进入Hashtable。</p>
<ul>
<li>HashTable 只有一把锁，当一个线程访问 HashTable 的同步方法时，会将整张 table 锁住，当其他线程也想访问 HashTable 同步方法时，就会进入阻塞或轮询状态。也就是确保同一时间只有一个线程对同步方法的占用，避免多个线程同时对数据的修改，确保线程的安全性。但是 HashTable 对 get，put，remove 方法都使用了同步操作，这就造成如果两个线程都只想使用get 方法去读取数据时，因为一个线程先到进行了锁操作，另一个线程就不得不等待，这样必然导致效率低下，而且竞争越激烈，效率越低下。</li>
</ul>
<h3 id="jdk-17-concurrenthashmap">JDK 1.7 ConcurrentHashMap</h3>
<p><strong>ReentrantLock + Segment + HashEntry</strong></p>
<p><strong>JDK1.7之前的 ConcurrentHashMap 使用分段锁机制实现。(JDK 1.5—JDK1.7)</strong></p>
<ul>
<li>ConcurrentHashMap 在对象中保存了一个Segment数组，即将整个Hash表划分为多个分段；而每个Segment元素，即每个分段则类似于一个Hashtable；这样，在执行put操作时首先根据hash算法定位到元素属于哪个Segment，然后对该Segment加锁即可。</li>
</ul>
<hr>
<h3 id="jdk-18-concurrenthashmap">JDK 1.8 ConcurrentHashMap</h3>
<p><strong>Synchronized + CAS + HashEntry + Red-Black Tree</strong></p>
<p><strong>JDK 1.8 已经抛弃了Segment的概念，虽然源码里面还保留了，也只是为了兼容性的考虑。</strong><br>
<strong>JDK1.8 则使用<code>数组+链表+红黑树数据结构、并发控制使用Synchronized和CAS原子操作</code>实现ConcurrentHashMap</strong></p>
<h4 id="cas原理-乐观锁">CAS原理 （乐观锁）</h4>
<p><strong>一般地，锁分为悲观锁和乐观锁：</strong></p>
<ul>
<li>
<p><strong><code>悲观锁</code></strong> 认为对于同一个数据的并发操作，一定是为发生修改的；</p>
</li>
<li>
<p><strong><code>乐观锁</code></strong> 认为对于同一个数据的并发操作是不会发生修改的，在更新数据时会采用尝试更新不断重试的方式更新数据。</p>
</li>
</ul>
<hr>
<ul>
<li><strong>CAS有三个操作数：</strong>
<ul>
<li>内存值 V</li>
<li>预估值 A</li>
<li>更新值 B</li>
</ul>
</li>
</ul>
<p><strong>当且仅当 V == A 时，–&gt; V = B; B 赋值给 V 否则，不会执行任何操作。</strong></p>
<h4 id="模拟cas算法">模拟CAS算法</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCompareAndSwap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> CompareAndSwap cas = <span class="keyword">new</span> CompareAndSwap();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*new Thread(new Runnable() &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                @Override</span></span><br><span class="line"><span class="comment">                public void run() &#123;</span></span><br><span class="line"><span class="comment">                    int expectedValue = cas.get();</span></span><br><span class="line"><span class="comment">                    boolean b = cas.compareAndSet(expectedValue, (int) (Math.random() * 101));</span></span><br><span class="line"><span class="comment">                    System.out.println(b);</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;).start();*/</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt;</span><br><span class="line">                    System.out.println(cas.compareAndSet(cas.get(), (<span class="keyword">int</span>) (Math.random() * <span class="number">101</span>)))</span><br><span class="line">            ).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompareAndSwap</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="comment">//获取内存值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//比较</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">compareAndSwap</span><span class="params">(<span class="keyword">int</span> expectedValue, <span class="keyword">int</span> newValue)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> oldValue = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(oldValue == expectedValue)&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = newValue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expectedValue, <span class="keyword">int</span> newValue)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> expectedValue == compareAndSwap(expectedValue, newValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="concurrenthashmap-的put方法实现">ConcurrentHashMap 的put方法实现</h4>
<p><strong>实现思路：</strong></p>
<ul>
<li>
<p><strong>1.如果没有初始化就先调用 initTable() 方法来进行初始化过程。</strong></p>
</li>
<li>
<p><strong>2.如果没有hash冲突就直接CAS插入。</strong></p>
</li>
<li>
<p><strong>3.如果还在进行扩容操作就先进行扩容。</strong></p>
</li>
<li>
<p><strong>4.如果存在hash冲突，就加锁来保证线程安全，这里有两种情况，一种是链表形式就直接遍历到尾端插入，一种是红黑树就按照红黑树结构插入</strong>。</p>
</li>
<li>
<p><strong>5.最后一个如果该链表的数量大于阈值8，就要先转换成黑红树的结构，break再一次进入循环</strong>。</p>
</li>
<li>
<p><strong>6.如果添加成功就调用 addCount() 方法统计size，并且检查是否需要扩容</strong>。</p>
</li>
</ul>
<hr>
<h4 id="concurrenthashmap-的get方法实现">ConcurrentHashMap 的get方法实现</h4>
<p><strong>实现思路：</strong></p>
<ul>
<li>
<p><strong>1.计算hash值，定位到该table索引位置，如果是首节点符合就返回</strong>。</p>
</li>
<li>
<p><strong>2.如果遇到扩容的时候，会调用标志正在扩容节点ForwardingNode的find方法，查找该节点，匹配就返回</strong>。</p>
</li>
<li>
<p><strong>3.以上都不符合的话，就往下遍历节点，匹配就返回，否则最后就返回null</strong> 。</p>
</li>
</ul>
<hr>
<h2 id="6-java集合类框架的基本接口">6、Java集合类框架的基本接口</h2>
<ul>
<li>
<p><strong>Collection:代表一组对象，每一个对象都是他的子元素;</strong></p>
<ul>
<li>
<p><strong>Set：不包含重复元素的Collection；</strong></p>
<ul>
<li><strong>HashSet</strong></li>
</ul>
</li>
<li>
<p><strong>List：有序的Collection，可以包含重复元素；</strong></p>
<ul>
<li>
<p><strong>ArrayList</strong></p>
</li>
<li>
<p><strong>LinkedList</strong></p>
</li>
<li>
<p><strong>Vector</strong></p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Map：将key映射到value的对象，key不能重复。</strong></p>
<ul>
<li><strong>HashMap</strong></li>
</ul>
</li>
</ul>
<hr>
<h2 id="7-关于listmapsetvectorhashtable">7、关于List,Map,Set,Vector,HashTable</h2>
<h3 id="list">List 👇</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testArrayList</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="keyword">null</span>);</span><br><span class="line">    list.add(<span class="keyword">null</span>);</span><br><span class="line">    Assert.assertEquals(<span class="number">2</span>,list.size()); <span class="comment">// success</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLinkedList</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LinkedList&lt;String&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    list.add(<span class="keyword">null</span>);</span><br><span class="line">    list.add(<span class="keyword">null</span>);</span><br><span class="line">    Assert.assertEquals(<span class="number">2</span>,list.size()); <span class="comment">// success</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>ArrayList底层是数组，可以存储多个null，添加 null 并未对他的数据结构造成影响。</strong></li>
<li><strong>LinkedList 底层为双向链表，<code>node.value = null</code>也没有影响。</strong></li>
</ul>
<hr>
<h3 id="map">Map 👇</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    map.put(<span class="keyword">null</span>, <span class="string">"1"</span>);</span><br><span class="line">    map.put(<span class="string">"2"</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">        String key = entry.getKey();</span><br><span class="line">        String value = entry.getValue();</span><br><span class="line">        System.out.println(key + <span class="string">"-&gt;"</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">    Assert.assertEquals(<span class="number">2</span>, map.size()); <span class="comment">//OK size = 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTreeMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TreeMap&lt;String, String&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    Assert.assertEquals(<span class="number">1</span>, map.size()); <span class="comment">//Error NullPointException</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>HashMap中最多只有一个<code>key == null</code>的节点，因为key相同时，后面的节点会替换之前相同key的节点，所以HashMap是可以添加<code>key == null</code>的节点的，只不过只会存在一个，并且 put() 方法返回旧值。</strong></li>
<li><strong>TreeMap的put方法会调用 compareTo 方法，对象为null时，会报空指针错。</strong>
<ul>
<li><strong>TreeMap存储两个对象Key和Value（仅仅key对象有序，根据键排序的有序集合)</strong>。</li>
<li><strong>TreeMap的底层采用红黑树的实现，完成数据有序的插入，排序。</strong></li>
</ul>
</li>
</ul>
<hr>
<h3 id="set">Set👇</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHashSet</span><span class="params">()</span></span>&#123;</span><br><span class="line">    HashSet&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    set.add(<span class="keyword">null</span>);</span><br><span class="line">    Assert.assertEquals(<span class="number">1</span>,set.size()); <span class="comment">//OK size = 1</span></span><br><span class="line">    set.add(<span class="keyword">null</span>);</span><br><span class="line">    Assert.assertEquals(<span class="number">2</span>,set.size()); <span class="comment">//Error size = 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTreeSet</span><span class="params">()</span></span>&#123;</span><br><span class="line">    TreeSet&lt;String&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">    set.add(<span class="keyword">null</span>); <span class="comment">//Error NullPointException</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><strong>HashSet 底层是HashMap，所以它的 add() 调用的是 HashMap的 put()  ，也只能有一个null。</strong></p>
<ul>
<li>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>TreeSet 的 add() 方法会调用 compareTo 方法，对象为null时，会报空指针错。</strong></p>
<ul>
<li>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>TreeSet中不能有重复对象，而TreeMap中可以存在。(排序集合)</strong></p>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="vector">Vector 👇</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">VectorTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Vector box = <span class="keyword">new</span> Vector();</span><br><span class="line">    box.add(<span class="keyword">null</span>);</span><br><span class="line">    box.add(<span class="keyword">null</span>);</span><br><span class="line">    Assert.assertEquals(<span class="number">2</span>,box.size()); <span class="comment">//ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><strong>Vector 底层是数组，可以存储多个null。add() 方法如下：</strong></p>
<ul>
<li>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="hashtable">HashTable 👇</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HashTableTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Hashtable table = <span class="keyword">new</span> Hashtable();</span><br><span class="line">    table.put(<span class="keyword">new</span> Object(),<span class="keyword">null</span>); <span class="comment">//Exception</span></span><br><span class="line">    <span class="comment">//table.put(null,new Object()); //Exception</span></span><br><span class="line">    <span class="comment">//table.put(null,null); //Exception</span></span><br><span class="line">    Assert.assertEquals(<span class="number">1</span>,table.size());<span class="comment">//NullPointerException</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><strong>底层为散列表，无论是key为null，还是value为null，都会报错。</strong></p>
</li>
<li>
<p><strong>Why —&gt; 源码奉上：</strong></p>
<ul>
<li>
<p>459行 -&gt; value 需要判空，所以value不可为null。</p>
</li>
<li>
<p>465行 -&gt; key需要拥有实例去调用hashCode方法，所以也不能为空。</p>
</li>
<li>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Make sure the value is not null</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123; <span class="comment">//value 需要判空，所以value不可为null</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Makes sure the key is not already in the hashtable.</span></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="keyword">int</span> hash = key.hashCode();<span class="comment">//key需要拥有实例去调用hashCode方法，所以也不能为空</span></span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    <span class="keyword">for</span>(; entry != <span class="keyword">null</span> ; entry = entry.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">            V old = entry.value;</span><br><span class="line">            entry.value = value;</span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addEntry(hash, key, value, index);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>因为 HashTable，ConcurrentHashMap 用于多线程，并发。如果 table.get(key) 得到了null，不能判断到底是映射的 value 是null，还是因为没有找到对应的 key 而为空，而用于单线程状态的 HashMap 却可以containsKey() 去判断到底是否包含了这个 null；</strong></p>
</li>
<li>
<p><strong>为什么 HashTable 不能 containsKey()？</strong></p>
<ul>
<li>多线程状态下，一个线程先 table.get(key) 再 table.containsKey(key)，在这两个方法的中间时刻，其他线程可能会操作这个 key ，例如删除 这个 key；所以不安全。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="总结">总结</h3>
<ul>
<li>List 都可以添加 null 元素。</li>
<li>HashMap 可以有1个key为null的元素，TreeMap不能有key为 null 的元素。</li>
<li>Set底层是Map：
<ul>
<li>所以HashSet可以有1个null的元素，TreeSet不能有key为 null 的元素。</li>
</ul>
</li>
<li>Vector 底层是数组，可以存储多个null。</li>
<li>HashTable 底层为散列表，无论是key为null，还是value为null，都会报错。</li>
</ul>
<hr>
<h2 id="8-多线程">8、多线程</h2>
<h3 id="什么是线程">什么是线程？</h3>
<p><strong>根本区别：进程是操作系统资源分配的基本单位，而线程是 CPU 任务调度和执行的基本单位</strong>。</p>
<ul>
<li><strong>一个程序(进程)同时执行多个任务，每一个任务称为一个线程。</strong></li>
<li><strong>进程是线程的容器，不存在没有线程的进程的。</strong></li>
</ul>
<h3 id="进程与线程区别"><strong>进程与线程区别</strong></h3>
<ul>
<li><strong>进程</strong>
<ul>
<li>进程是程序运行和操作系统资源分配的基本单位;</li>
<li>同一进程中的多个线程之间可以并发执行。</li>
<li>本质区别在于每个进程拥有自己的一套变量使用自己的内存空间；</li>
</ul>
</li>
<li><strong>线程</strong>
<ul>
<li>线程是进程的子集，一个进程可以有很多线程；</li>
<li>线程则共享一片相同的内存空间；每个线程都拥有单独的栈内存用来存储本地数据。</li>
<li>共享变量使线程之间的通信比进程之间的通信更有效，更容易；</li>
<li>线程更加“轻量级”，创建、撤销一个线程比启动新进程的开销小得多。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="守护线程与非守护线程">守护线程与非守护线程</h3>
<ul>
<li>
<p><strong>程序运行完毕，jvm会等待非守护线程完成后关闭，但是jvm不会等待守护线程。</strong></p>
</li>
<li>
<p><strong>守护线程最典型的例子就是GC线程。</strong></p>
</li>
</ul>
<h4 id="守护线程">守护线程</h4>
<ul>
<li><strong>垃圾回收线程：GC线程</strong></li>
<li><strong>当主线程运行的时候，垃圾回收线程一起运行。当主线程销毁，会和主线程一起销毁。</strong></li>
</ul>
<h4 id="非守护线程用户线程">非守护线程(用户线程)</h4>
<ul>
<li><strong>非守护线程即我们手动创建的线程</strong>。</li>
<li><strong>如果主线程销毁，用户线程继续运行且互不影响。</strong></li>
</ul>
<p><strong>创建守护线程</strong> 👇</p>
<ul>
<li><strong>必须在 <code>t1.start()</code>之前设置守护线程 <code>t1.setDaemon(true);</code></strong></li>
<li><strong>不能把正在运行的常规线程设置为守护线程,否则报IllegalThreadStateException异常。</strong></li>
<li><strong>主线程结束之后并没有在继续运行守护线程，守护线程也跟着结束，一起销毁停止。</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaemonThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">/*Thread t1 = new Thread(new Runnable() &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public void run() &#123;</span></span><br><span class="line"><span class="comment">                while (true) &#123;</span></span><br><span class="line"><span class="comment">                    try &#123;</span></span><br><span class="line"><span class="comment">                        Thread.sleep(1000);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                    &#125; catch (Exception e) &#123;</span></span><br><span class="line"><span class="comment">                        e.printStackTrace();</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                    System.out.println("我是子线程(用户线程)");</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;);*/</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"我是子线程(用户线程)"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO 标识当前方法为守护线程，一定要在启动线程前设置为守护线程</span></span><br><span class="line">        t1.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//相当与主线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">300</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"main:i:"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"主线程执行完毕..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO</span></span><br><span class="line">main:i:<span class="number">0</span></span><br><span class="line">main:i:<span class="number">1</span></span><br><span class="line">main:i:<span class="number">2</span></span><br><span class="line">我是子线程(用户线程)</span><br><span class="line">main:i:<span class="number">3</span></span><br><span class="line">main:i:<span class="number">4</span></span><br><span class="line">main:i:<span class="number">5</span></span><br><span class="line">我是子线程(用户线程)</span><br><span class="line">main:i:<span class="number">6</span></span><br><span class="line">main:i:<span class="number">7</span></span><br><span class="line">main:i:<span class="number">8</span></span><br><span class="line">我是子线程(用户线程)</span><br><span class="line">main:i:<span class="number">9</span></span><br><span class="line">主线程执行完毕...</span><br></pre></td></tr></table></figure>
<p><strong>非守护线程：如果主线程销毁，用户线程继续运行且互不影响。</strong> 👇</p>
<p><strong>当主线程销毁停止，非守护线程（用户线程）并没有结束，而是一直在执行，与主线程互不影响。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotDaemonThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">/* Thread t1 = new Thread(new Runnable() &#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public void run() &#123;</span></span><br><span class="line"><span class="comment">                while (true) &#123;</span></span><br><span class="line"><span class="comment">                    try &#123;</span></span><br><span class="line"><span class="comment">                        Thread.sleep(1000);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                    &#125; catch (Exception e) &#123;</span></span><br><span class="line"><span class="comment">                        e.printStackTrace();</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                    System.out.println("我是子线程(用户线程)");</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;);*/</span></span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"我是子线程(用户线程)"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// TODO 启动线程 没有开启守护线程</span></span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//相当与主线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">300</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"main:i:"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"主线程执行完毕..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO</span></span><br><span class="line">main:i:<span class="number">0</span></span><br><span class="line">main:i:<span class="number">1</span></span><br><span class="line">main:i:<span class="number">2</span></span><br><span class="line">我是子线程(用户线程)</span><br><span class="line">main:i:<span class="number">3</span></span><br><span class="line">main:i:<span class="number">4</span></span><br><span class="line">main:i:<span class="number">5</span></span><br><span class="line">我是子线程(用户线程)</span><br><span class="line">main:i:<span class="number">6</span></span><br><span class="line">main:i:<span class="number">7</span></span><br><span class="line">main:i:<span class="number">8</span></span><br><span class="line">我是子线程(用户线程)</span><br><span class="line">main:i:<span class="number">9</span></span><br><span class="line">主线程执行完毕...</span><br><span class="line">我是子线程(用户线程)</span><br><span class="line">我是子线程(用户线程)</span><br><span class="line">我是子线程(用户线程)</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="9-synchronized-amp-lock-区别">9、Synchronized &amp; lock 区别</h2>
<p><strong>synchronized是关键字属于JVM层面，底层是通过monitor对象来完成，其实wait/notify等方法也依赖monitor 对象只有在同步代码块和同步方法中才能调用wait/notify等方法)</strong></p>
<p><strong>Lock 是一个接口，是 API 层面的锁；默认非公平锁。</strong></p>
<ul>
<li><strong>锁的释放：</strong>
<ul>
<li><strong><code>Synchronized</code> 在线程发生异常时会自动释放锁，因此不会发生异常死锁。</strong></li>
<li><strong><code>Lock</code> 异常时不会自动释放锁，所以需要在finally中实现释放锁。</strong></li>
</ul>
</li>
<li><strong>锁的获取：</strong>
<ul>
<li><strong><code>Synchronized</code> 假设A线程获得锁，B线程等待。如果A线程阻塞，B线程会一直等待。</strong></li>
<li><strong><code>Lock</code> 需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；</strong></li>
</ul>
</li>
<li><strong>底层实现区别：</strong>
<ul>
<li><strong>Synchronized：</strong> 底层使用指令码方式来控制锁的，映射成字节码指令就是增加来两个指令：<code>monitorenter</code> 和 <code>monitorexit</code>。当线程执行遇到 <code>monitorenter</code> 指令时会尝试获取内置锁，如果获取锁则锁计数器+1，如果没有获取锁则阻塞；当遇到 <code>monitorexit</code> 指令时锁计数器-1，如果计数器为0则释放锁。</li>
<li><strong>Lock：</strong> 底层是CAS乐观锁，依赖 AbstractQueuedSynchronizer 类，把所有的请求线程构成一个CLH队列。而对该队列的操作均通过Lock-Free（CAS）操作。</li>
</ul>
</li>
<li><strong>Lock 可以使用读锁提高多线程读效率。（ReadWriteLock）</strong></li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">层次</th>
<th style="text-align:center">Synchronized Java关键字，jvm 层面上</th>
<th style="text-align:center">Lock 是一个接口，Java API 层</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">锁状态</td>
<td style="text-align:center">无法判断</td>
<td style="text-align:center">可以判断</td>
</tr>
<tr>
<td style="text-align:center">锁类型</td>
<td style="text-align:center"><strong>隐式锁</strong>  可重入 不可中断  非公平</td>
<td style="text-align:center"><strong>显示锁</strong> 可重入 可中断 可公平（两者皆可）</td>
</tr>
<tr>
<td style="text-align:center">性能</td>
<td style="text-align:center">悲观锁 适用少量同步</td>
<td style="text-align:center">乐观锁（CAS） 适用大量同步</td>
</tr>
<tr>
<td style="text-align:center">唤醒</td>
<td style="text-align:center">随机唤醒 1 个或 唤醒全部线程。</td>
<td style="text-align:center">可精确唤醒</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="锁的分类">锁的分类</h3>
<ul>
<li><strong>可重入锁：</strong> Synchronized和ReentrantLook都是可重入锁，锁的可重入性标明了锁是针对线程分配方式而不是针对方法。例如调用Synchronized方法A中可以调用Synchronized方法B，而不需要重新申请锁。</li>
<li><strong>读写锁：</strong> 按照数据库事务隔离特性的类比读写锁，在访问统一个资源（一个文件）的时候，使用读锁来保证多线程可以同步读取资源。ReadWriteLock是一个读写锁，通过readLock()获取读锁，通过writeLock()获取写锁。</li>
<li><strong>可中断锁：</strong> 可中断是指锁是可以被中断的，Synchronized内置锁是不可中断锁，ReentrantLock可以通过lockInterruptibly() 方法中断显性锁。例如线程B在等待线程A释放锁，但是线程B由于等待时间太久，可以主动中断等待锁。</li>
<li><strong>公平锁：</strong> 公平锁是指尽量以线程的等待时间先后顺序获取锁，等待时间最久的线程优先获取锁。synchronized 隐性锁是非公平锁，它无法保证等待的线程获取锁的顺序，ReentrantLook可以自己控制是否公平锁。</li>
</ul>
<hr>
<h3 id="reentrantlock-公平锁和非公平锁">ReentrantLock 公平锁和非公平锁</h3>
<p><strong>ReentrantLock 默认采用非公平锁，除非在构造方法中传入参数 true ，为公平锁。源码如下：👇</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125;.</span></span><br><span class="line"><span class="comment">* This is equivalent to using &#123;<span class="doctag">@code</span> ReentrantLock(false)&#125;.</span></span><br><span class="line"><span class="comment">* default false</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125; with the</span></span><br><span class="line"><span class="comment">* given fairness policy.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> fair &#123;<span class="doctag">@code</span> true&#125; if this lock should use a fair ordering policy</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="10-产生死锁的条件">10、产生死锁的条件</h2>
<p>死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。</p>
<p><strong>死锁的发生必须满足以下四个条件：</strong></p>
<ul>
<li>互斥条件：一个资源每次只能被一个进程使用。</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。</li>
<li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ul>
<hr>
<h2 id="10-为什么选择mysql数据库">10、为什么选择MySQL数据库</h2>
<ul>
<li>2008年阿里提出去IOE。O—&gt;Oracle</li>
<li>MySql 性能卓越，服务稳定，很少出现宕机；</li>
<li>开放源代码且无版权制约，自主性，使用成本低；</li>
<li>历史悠久，社区用户非常活跃，遇到问题可以寻求帮助；</li>
<li>软件体积小，安装使用简单，并且易于维护；</li>
<li>品牌口碑效应，使得企业无需考虑就直接用之，LAMP LEMP流行架构；</li>
<li>支持多种操作系统，提供多个API接口，支持多个开发语言。</li>
</ul>
<hr>
<h2 id="11-系统设置的主键与我们定义的主键区别">11、系统设置的主键与我们定义的主键区别</h2>
<ul>
<li>没有根本性区别，只是系统自动添加的一般数据类型是自动编号型，数据是系统维护；</li>
<li>而自己定义的主键，可以选择其他数据类型，自己维护数据。</li>
</ul>
<hr>
<h2 id="12-有无主键区别">12、有无主键区别</h2>
<ul>
<li>没有主键，表中可以有重复的行；</li>
<li>有主键，表中不可以有重复的行；</li>
<li>主键的好处是能唯一确定表中的行，体现到现实世界中就是能区别事物。多个字段为表的主键代表这些字段的值组合起来才能确定表中的一行，选课（学生学号，课程号，分数）主键为学号和课程号的组合，只有这两个值确定了，选课表中的一行才能被唯一的确定。</li>
</ul>

                

                <hr>
                <!-- Pager -->
                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/article/ShardingSphere/" data-toggle="tooltip" data-placement="top" title="ShardingSphere">&larr; Previous Post</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/article/java-util-concurrent/" data-toggle="tooltip" data-placement="top" title="java.util.concurrent">Next Post &rarr;</a>
                        </li>
                    
                </ul>

                <br>

                <!--打赏-->
                
                    <div class="reward">
                        <div class="reward-button">赏 <span class="reward-code"> 
                            <span class="alipay-code"> <img class="alipay-img" src="http://ww1.sinaimg.cn/large/006vWPzFly1g0o77ru34uj30dz0drdhv.jpg"><b>支付宝打赏</b></span> 
                            <span class="wechat-code"> <img class="wechat-img" src="http://ww1.sinaimg.cn/large/006vWPzFly1g0o740lhb9j30rb0ov77z.jpg"><b>微信打赏</b> </span>
                            </span></div>
                        <p class="reward-notice">赞赏一下</p>
                    </div>
                
                <!--打赏-->

                <br>
                <!--分享-->
                
                <!--分享-->
                <br>                       
                
                <!-- require APlayer -->
                

                <!-- duoshuo Share start -->
                
                <!-- 多说 Share end-->

                <!-- 多说评论框 start -->
                
                <!-- 多说评论框 end -->

                <!-- disqus comment start -->
                
                <!-- disqus comment end -->

                

            </div>
            
            <!-- Tabe of Content -->
            <!-- Table of Contents -->

  
    <style>
      span.toc-nav-number{
        display: none
      }
    </style>
  
    
      <aside id="sidebar">
        <div id="toc" class="toc-article">
        <strong class="toc-title">Contents</strong>
        
          <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#1-equals-amp-hashcode"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">1&#x3001;equals() &amp; hashCode()</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#2-equals-amp"><span class="toc-nav-number">2.</span> <span class="toc-nav-text">2&#x3001;equals &amp; ==</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#"><span class="toc-nav-number">2.1.</span> <span class="toc-nav-text"></span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#3-hashmap"><span class="toc-nav-number">3.</span> <span class="toc-nav-text">3&#x3001;HashMap</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jdk-18-hashmap-实现原理"><span class="toc-nav-number">3.1.</span> <span class="toc-nav-text">JDK 1.8 HashMap &#x5B9E;&#x73B0;&#x539F;&#x7406;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#存储结构-字段"><span class="toc-nav-number">3.1.1.</span> <span class="toc-nav-text">&#x5B58;&#x50A8;&#x7ED3;&#x6784;-&#x5B57;&#x6BB5;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#hash-冲突"><span class="toc-nav-number">3.1.2.</span> <span class="toc-nav-text">Hash &#x51B2;&#x7A81;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#扩容机制"><span class="toc-nav-number">3.1.3.</span> <span class="toc-nav-text">&#x6269;&#x5BB9;&#x673A;&#x5236;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#hashmap的put方法实现"><span class="toc-nav-number">3.1.4.</span> <span class="toc-nav-text">HashMap&#x7684;put&#x65B9;&#x6CD5;&#x5B9E;&#x73B0;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#hashmap的get方法实现"><span class="toc-nav-number">3.1.5.</span> <span class="toc-nav-text">HashMap&#x7684;get&#x65B9;&#x6CD5;&#x5B9E;&#x73B0;</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#4-hashset"><span class="toc-nav-number">4.</span> <span class="toc-nav-text">4&#x3001;HashSet</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#hashset-元素不重复"><span class="toc-nav-number">4.1.</span> <span class="toc-nav-text">HashSet &#x5143;&#x7D20;&#x4E0D;&#x91CD;&#x590D;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#5-concurrenthashmap"><span class="toc-nav-number">5.</span> <span class="toc-nav-text">5&#x3001;ConcurrentHashMap</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jdk-17-concurrenthashmap"><span class="toc-nav-number">5.1.</span> <span class="toc-nav-text">JDK 1.7 ConcurrentHashMap</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#jdk-18-concurrenthashmap"><span class="toc-nav-number">5.2.</span> <span class="toc-nav-text">JDK 1.8 ConcurrentHashMap</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#cas原理-乐观锁"><span class="toc-nav-number">5.2.1.</span> <span class="toc-nav-text">CAS&#x539F;&#x7406; &#xFF08;&#x4E50;&#x89C2;&#x9501;&#xFF09;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#模拟cas算法"><span class="toc-nav-number">5.2.2.</span> <span class="toc-nav-text">&#x6A21;&#x62DF;CAS&#x7B97;&#x6CD5;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#concurrenthashmap-的put方法实现"><span class="toc-nav-number">5.2.3.</span> <span class="toc-nav-text">ConcurrentHashMap &#x7684;put&#x65B9;&#x6CD5;&#x5B9E;&#x73B0;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#concurrenthashmap-的get方法实现"><span class="toc-nav-number">5.2.4.</span> <span class="toc-nav-text">ConcurrentHashMap &#x7684;get&#x65B9;&#x6CD5;&#x5B9E;&#x73B0;</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#6-java集合类框架的基本接口"><span class="toc-nav-number">6.</span> <span class="toc-nav-text">6&#x3001;Java&#x96C6;&#x5408;&#x7C7B;&#x6846;&#x67B6;&#x7684;&#x57FA;&#x672C;&#x63A5;&#x53E3;</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#7-关于listmapsetvectorhashtable"><span class="toc-nav-number">7.</span> <span class="toc-nav-text">7&#x3001;&#x5173;&#x4E8E;List,Map,Set,Vector,HashTable</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#list"><span class="toc-nav-number">7.1.</span> <span class="toc-nav-text">List &#x1F447;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#map"><span class="toc-nav-number">7.2.</span> <span class="toc-nav-text">Map &#x1F447;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#set"><span class="toc-nav-number">7.3.</span> <span class="toc-nav-text">Set&#x1F447;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#vector"><span class="toc-nav-number">7.4.</span> <span class="toc-nav-text">Vector &#x1F447;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#hashtable"><span class="toc-nav-number">7.5.</span> <span class="toc-nav-text">HashTable &#x1F447;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#总结"><span class="toc-nav-number">7.6.</span> <span class="toc-nav-text">&#x603B;&#x7ED3;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#8-多线程"><span class="toc-nav-number">8.</span> <span class="toc-nav-text">8&#x3001;&#x591A;&#x7EBF;&#x7A0B;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#什么是线程"><span class="toc-nav-number">8.1.</span> <span class="toc-nav-text">&#x4EC0;&#x4E48;&#x662F;&#x7EBF;&#x7A0B;&#xFF1F;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#进程与线程区别"><span class="toc-nav-number">8.2.</span> <span class="toc-nav-text"><strong>&#x8FDB;&#x7A0B;&#x4E0E;&#x7EBF;&#x7A0B;&#x533A;&#x522B;</strong></span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#守护线程与非守护线程"><span class="toc-nav-number">8.3.</span> <span class="toc-nav-text">&#x5B88;&#x62A4;&#x7EBF;&#x7A0B;&#x4E0E;&#x975E;&#x5B88;&#x62A4;&#x7EBF;&#x7A0B;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#守护线程"><span class="toc-nav-number">8.3.1.</span> <span class="toc-nav-text">&#x5B88;&#x62A4;&#x7EBF;&#x7A0B;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#非守护线程用户线程"><span class="toc-nav-number">8.3.2.</span> <span class="toc-nav-text">&#x975E;&#x5B88;&#x62A4;&#x7EBF;&#x7A0B;(&#x7528;&#x6237;&#x7EBF;&#x7A0B;)</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#9-synchronized-amp-lock-区别"><span class="toc-nav-number">9.</span> <span class="toc-nav-text">9&#x3001;Synchronized &amp; lock &#x533A;&#x522B;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#锁的分类"><span class="toc-nav-number">9.1.</span> <span class="toc-nav-text">&#x9501;&#x7684;&#x5206;&#x7C7B;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#reentrantlock-公平锁和非公平锁"><span class="toc-nav-number">9.2.</span> <span class="toc-nav-text">ReentrantLock &#x516C;&#x5E73;&#x9501;&#x548C;&#x975E;&#x516C;&#x5E73;&#x9501;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#10-产生死锁的条件"><span class="toc-nav-number">10.</span> <span class="toc-nav-text">10&#x3001;&#x4EA7;&#x751F;&#x6B7B;&#x9501;&#x7684;&#x6761;&#x4EF6;</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#10-为什么选择mysql数据库"><span class="toc-nav-number">11.</span> <span class="toc-nav-text">10&#x3001;&#x4E3A;&#x4EC0;&#x4E48;&#x9009;&#x62E9;MySQL&#x6570;&#x636E;&#x5E93;</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#11-系统设置的主键与我们定义的主键区别"><span class="toc-nav-number">12.</span> <span class="toc-nav-text">11&#x3001;&#x7CFB;&#x7EDF;&#x8BBE;&#x7F6E;&#x7684;&#x4E3B;&#x952E;&#x4E0E;&#x6211;&#x4EEC;&#x5B9A;&#x4E49;&#x7684;&#x4E3B;&#x952E;&#x533A;&#x522B;</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#12-有无主键区别"><span class="toc-nav-number">13.</span> <span class="toc-nav-text">12&#x3001;&#x6709;&#x65E0;&#x4E3B;&#x952E;&#x533A;&#x522B;</span></a></li></ol>
        
        </div>
      </aside>
    

                
            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#面试" title="面试">面试</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">

                    
                        <li><a href="https://yexua.github.io/" target="_blank">大佬</a></li>
                    
                        <li><a href="https://snailclimb.gitee.io/javaguide/#/" target="_blank">JavaGuide</a></li>
                    
                        <li><a href="http://cyc2018.gitee.io/cs-notes/#/notes/%E5%89%91%E6%8C%87%20Offer%20%E9%A2%98%E8%A7%A3%20-%20%E7%9B%AE%E5%BD%951" target="_blank">剑指Offer</a></li>
                    
                        <li><a href="http://cyc2018.gitee.io/cs-notes/#/" target="_blank">技术面试必备基础知识</a></li>
                    
                </ul>
                
            </div>
        </div>
    </div>
</article>








<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'left',
          icon: 'ℬ'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                

                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/GitHub-yuteng">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; 于腾 2019 
                    <br>
                    Theme by <a href="http://beantech.org">BeanTech</a> 
                    <span style="display: inline-block; margin: 0 5px;">
                        <i class="fa fa-heart"></i>
                    </span> 
                    re-Ported by <a href="http://www.huweihuang.com">胡伟煌</a> | 
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="91px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=huweihuang&repo=hexo-theme-huweihuang&type=star&count=true" >
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("https://github-yuteng.github.io/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->


<script>
    // dynamic User by Hux
    var _gaId = 'UA-XXXXXXXX-X';
    var _gaDomain = 'yoursite';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>




<!-- Baidu Tongji -->

<script>
    // dynamic User by Hux
    var _baId = 'xxx';

    // Originial
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?" + _baId;
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
</script>






	<a id="rocket" href="#top" class=""></a>
	<script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
    <script type="text/javascript" src="/js/toc.js?v=1.0.0" async=""></script>
<!-- Image to hack wechat -->
<img src="https://github-yuteng.github.io/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
