<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/ironman-draw.png">
    <!-- Place this tag in your head or just before your close body tag. -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <title>
        
          NIO（Non-Blocking IO） - 于腾 | Blog
        
    </title>

    <link rel="canonical" href="https://github-yuteng.github.io/article/NIO/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS --> 
    <link rel="stylesheet" href="/css/beantech.min.css">

    <link rel="stylesheet" href="/css/donate.css">
    
    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="/css/highlight.css">

    <link rel="stylesheet" href="/css/widget.css">

    <link rel="stylesheet" href="/css/rocket.css">

    <link rel="stylesheet" href="/css/signature.css">

    <link rel="stylesheet" href="/css/toc.css">

    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">
	<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        
            background-image: url('/img/article_header/article_bg.jpg')
            /*post*/
        
    }
    
</style>

<header class="intro-header" >
    <!-- Signature -->
    <div id="signature">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                
                    <div class="post-heading">
                        <div class="tags">
                            
                              <a class="tag" href="/tags/#NIO" title="NIO">NIO</a>
                            
                        </div>
                        <h1>NIO（Non-Blocking IO）</h1>
                        <h2 class="subheading"></h2>
                        <span class="meta">
                            Posted by 于腾 on
                            2019-04-25
                        </span>
                    </div>
                


                </div>
            </div>
        </div>
    </div>
</header>

	
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">所爱隔山海</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                        <li>
                            <a href="/about/">关于我</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/archive/">Archives</a>
                        </li>
                        
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    <!-- Modify by Yu-Hsuan Yen -->

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <h2 id="一-java-nio-简介">一、Java NIO 简介</h2>
<p><strong>Java NIO（New IO）是从Java 1.4版本开始引入的一个新的IO API，可以替代标准的Java IO API。 NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同。NIO支持面向缓冲区的、基于通道的IO操作。NIO将以更加高效的方式进行文件的读写操作。</strong></p>
<p><strong>java.nio.file</strong></p>
<table>
<thead>
<tr>
<th>IO</th>
<th>NIO</th>
</tr>
</thead>
<tbody>
<tr>
<td>面向流(Stream Oriented)</td>
<td>面向缓冲区(Buffer Oriented)</td>
</tr>
<tr>
<td>阻塞IO(Blocking IO)</td>
<td>非阻塞IO(Non Blocking IO)</td>
</tr>
<tr>
<td>(无)</td>
<td>选择器(Selectors)</td>
</tr>
</tbody>
</table>
<hr>
<hr>
<h2 id="二-通道channel与-缓冲区buffer">二、通道（Channel）与 缓冲区（Buffer）</h2>
<p><strong>Java NIO系统的核心在于：通道(Channel)和缓冲区 (Buffer)。</strong></p>
<p><strong>通道（Channel）：表示打开到 IO 设备(例如：文件、 套接字)的连接。若需要使用 NIO 系统，需要获取用于连接 IO 设备的通道以及用于容纳数据的缓冲区。然后操作缓冲区，对数据进行处理。</strong></p>
<hr>
<p><strong>缓冲区（Buffer）：一个用于特定基本数据类型的容器。由 java.nio 包定义的，所有缓冲区 都是 Buffer 抽象类的子类。</strong></p>
<p><strong><code>简而言之，Channel 负责传输， Buffer 负责存储</code></strong></p>
<img src="https://i.loli.net/2019/05/07/5cd0eee753841.png" alt="W8RUC4~6BWJ5QYN(UMJM54K.png" title="W8RUC4~6BWJ5QYN(UMJM54K.png">
<hr>
<hr>
<h3 id="1-缓冲区buffer">1、缓冲区（Buffer）</h3>
<p><strong>在 Java NIO 中负责数据的存取。缓冲区就是数组，用于存储不同数据类型的数据。</strong></p>
<p><strong>根据数据类型不同（boolean 除外），提供了相应类型的缓冲区：</strong></p>
<ul>
<li><strong><code>ByteBuffer</code></strong></li>
<li><strong>CharBuffer</strong></li>
<li><strong>ShortBuffer</strong></li>
<li><strong>IntBuffer</strong></li>
<li><strong>LongBuffer</strong></li>
<li><strong>FloatBuffer</strong></li>
<li><strong>DoubleBuffer</strong></li>
</ul>
<p><strong>上述缓冲区的管理方式几乎一致，通过 allocate() 获取缓冲区。</strong></p>
<ul>
<li><strong><code>ByteBuffer buf = ByteBuffer.allocate(1024);</code></strong></li>
</ul>
<hr>
<h4 id="缓冲区存取数据的核心方法">缓冲区存取数据的核心方法</h4>
<ul>
<li><strong>put()：存入数据到缓冲区中。</strong></li>
<li><strong>get()：获取缓冲区中的数据。</strong></li>
<li><strong>flip()：切换读取数据模式。</strong></li>
<li><strong>rewind()：可重复读。</strong></li>
<li><strong>clear()：清空缓冲区，但是缓冲区中的数据依然存在，但是处于“被遗忘”状态。</strong></li>
</ul>
<h4 id="缓冲区中的五个核心属性">缓冲区中的五个核心属性</h4>
<ul>
<li><strong>capacity（容量）：表示缓冲区中最大存储数据的容量。一旦声明不能改变。</strong></li>
<li><strong>limit（界限）：表示缓冲区中可以操作数据的大小。（limit 后数据不能进行读写）</strong></li>
<li><strong>position（位置）：表示缓冲区中正在操作数据的位置。</strong></li>
<li><strong>mark（标记）：表示记录当前 position 的位置。</strong></li>
<li><strong>reset（重置）：可以通过 reset() 恢复到 mark 的位置。</strong></li>
</ul>
<p><strong>标记、位置、限制、容量遵守以下不变式：</strong></p>
<ul>
<li><strong>0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity</strong></li>
</ul>
<hr>
<img src="https://i.loli.net/2019/05/07/5cd0fbc021bd9.png" alt="0K[1E(GU8R]AVS@C[X60%51.png" title="0K[1E(GU8R]AVS@C[X60%51.png">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBuffer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        String str = <span class="string">"abcde"</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1、分配一个指定大小的缓冲区</span></span><br><span class="line">        ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"-----------------allocate()----------------"</span>);</span><br><span class="line">        System.out.println(<span class="string">"position:"</span>+buf.position());</span><br><span class="line">        System.out.println(<span class="string">"limit:"</span>+buf.limit());</span><br><span class="line">        System.out.println(<span class="string">"capacity:"</span>+buf.capacity());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2、利用 put() 存入数据到缓冲区中</span></span><br><span class="line">        buf.put(str.getBytes());</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"-----------------put()----------------"</span>);</span><br><span class="line">        System.out.println(<span class="string">"position:"</span>+buf.position());</span><br><span class="line">        System.out.println(<span class="string">"limit:"</span>+buf.limit());</span><br><span class="line">        System.out.println(<span class="string">"capacity:"</span>+buf.capacity());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3、切换读取数据模式</span></span><br><span class="line">        buf.flip();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"-----------------flip()----------------"</span>);</span><br><span class="line">        System.out.println(<span class="string">"position:"</span>+buf.position());</span><br><span class="line">        System.out.println(<span class="string">"limit:"</span>+buf.limit());</span><br><span class="line">        System.out.println(<span class="string">"capacity:"</span>+buf.capacity());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4、利用 get() 读取缓冲区中的数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] dst = <span class="keyword">new</span> <span class="keyword">byte</span>[buf.limit()];</span><br><span class="line">        buf.get(dst);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(dst, <span class="number">0</span>, dst.length));</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"-----------------get()----------------"</span>);</span><br><span class="line">        System.out.println(<span class="string">"position:"</span>+buf.position());</span><br><span class="line">        System.out.println(<span class="string">"limit:"</span>+buf.limit());</span><br><span class="line">        System.out.println(<span class="string">"capacity:"</span>+buf.capacity());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5、rewind() : 可重复读</span></span><br><span class="line">        buf.rewind();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"-----------------rewind()----------------"</span>);</span><br><span class="line">        System.out.println(<span class="string">"position:"</span>+buf.position());</span><br><span class="line">        System.out.println(<span class="string">"limit:"</span>+buf.limit());</span><br><span class="line">        System.out.println(<span class="string">"capacity:"</span>+buf.capacity());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//6、clear() : 清空缓冲区. 但是缓冲区中的数据依然存在，但是处于“被遗忘”状态</span></span><br><span class="line">        buf.clear();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"-----------------clear()----------------"</span>);</span><br><span class="line">        System.out.println(<span class="string">"position:"</span>+buf.position());</span><br><span class="line">        System.out.println(<span class="string">"limit:"</span>+buf.limit());</span><br><span class="line">        System.out.println(<span class="string">"capacity:"</span>+buf.capacity());</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"-----------------get();----------------"</span>);</span><br><span class="line">        System.out.println((<span class="keyword">char</span>)buf.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>mark()、reset()</strong></p>
<img src="https://i.loli.net/2019/05/07/5cd0f9f2cd1db.png" alt="7E1(Q015)HUI1M}5T}{Q_{P.png" title="7E1(Q015)HUI1M}5T}{Q_{P.png">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String str = <span class="string">"abcde"</span>;</span><br><span class="line">    </span><br><span class="line">    ByteBuffer buf = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">    buf.put(str.getBytes());</span><br><span class="line">    buf.flip();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">byte</span>[] dst = <span class="keyword">new</span> <span class="keyword">byte</span>[buf.limit()];</span><br><span class="line">    buf.get(dst, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(dst, <span class="number">0</span>, <span class="number">2</span>));</span><br><span class="line">    System.out.println(<span class="string">"mark.position:"</span>+buf.position());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//mark() : 标记</span></span><br><span class="line">    buf.mark();</span><br><span class="line">    </span><br><span class="line">    buf.get(dst, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(dst, <span class="number">2</span>, <span class="number">2</span>));</span><br><span class="line">    System.out.println(<span class="string">"position:"</span>+buf.position());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//reset() : 恢复到  mark 的位置</span></span><br><span class="line">    buf.reset();</span><br><span class="line">    System.out.println(<span class="string">"reset.position:"</span>+buf.position());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断缓冲区中是否还有剩余数据</span></span><br><span class="line">    <span class="keyword">if</span>(buf.hasRemaining())&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//获取缓冲区中可以操作的数量</span></span><br><span class="line">        System.out.println(buf.remaining());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="buffer-的常用方法">Buffer 的常用方法</h4>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Buffer clear()</td>
<td>清空缓冲区并返回对缓冲区的引用</td>
</tr>
<tr>
<td>Buffer flip()</td>
<td>将缓冲区的界限设置为当前位置，并将当前位置充值为 0</td>
</tr>
<tr>
<td>int capacity()</td>
<td>返回 Buffer 的 capacity 大小</td>
</tr>
<tr>
<td>boolean hasRemaining()</td>
<td>判断缓冲区中是否还有元素</td>
</tr>
<tr>
<td>int limit()</td>
<td>返回 Buffer 的界限(limit) 的位置</td>
</tr>
<tr>
<td>Buffer limit(int n)</td>
<td>将设置缓冲区界限为 n, 并返回一个具有新 limit 的缓冲区对象</td>
</tr>
<tr>
<td>Buffer mark()</td>
<td>对缓冲区设置标记</td>
</tr>
<tr>
<td>int position()</td>
<td>返回缓冲区的当前位置 position</td>
</tr>
<tr>
<td>Buffer position(int n)</td>
<td>将设置缓冲区的当前位置为 n , 并返回修改后的 Buffer 对象</td>
</tr>
<tr>
<td>int remaining()</td>
<td>返回 position 和 limit 之间的元素个数</td>
</tr>
<tr>
<td>Buffer reset()</td>
<td>将位置 position 转到以前设置的 mark 所在的位置</td>
</tr>
<tr>
<td>Buffer rewind()</td>
<td>将位置设为为 0， 取消设置的 mark</td>
</tr>
</tbody>
</table>
<hr>
<h4 id="直接缓冲区与非直接缓冲区">直接缓冲区与非直接缓冲区</h4>
<ul>
<li><strong>非直接缓冲区：通过 allocate() 方法分配缓冲区，将缓冲区建立在 JVM 的内存中。</strong></li>
<li><strong><code>直接缓冲区</code>：通过 allocateDirect() 方法分配直接缓冲区，将缓冲区建立在<code>物理内存</code>中。可以提高效率</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//分配直接缓冲区</span></span><br><span class="line">    ByteBuffer buf = ByteBuffer.allocateDirect(<span class="number">1024</span>);</span><br><span class="line">    System.out.println(buf.isDirect());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>非直接缓冲区</strong><br>
<img src="https://i.loli.net/2019/05/07/5cd0fd97b1746.png" width="800"></p>
<hr>
<p><strong>直接缓冲区</strong><br>
<img src="https://i.loli.net/2019/05/07/5cd0fef980e2c.png" alt="ONQ]3V76W6GDMN@G9OLREE6.png" title="ONQ]3V76W6GDMN@G9OLREE6.png"></p>
<hr>
<hr>
<h3 id="2-通道channel">2、通道（Channel）</h3>
<p><strong>由 java.nio.channels 包定义的，用于源节点与目标节点的连接。</strong><br>
<strong>Channel 本身不存储数据，因此需要配合缓冲区进行传输。</strong></p>
<p><strong>Java 为 Channel 接口提供的最主要实现类如下：</strong></p>
<ul>
<li><strong>java.nio.channels.Channel 接口：</strong>
<ul>
<li><strong>FileChannel：用于读取、写入、映射和操作文件的通道。</strong></li>
<li><strong>DatagramChannel：通过 UDP 读写网络中的数据通道。</strong></li>
<li><strong>SocketChannel：通过 TCP 读写网络中的数据。</strong></li>
<li><strong>ServerSocketChannel：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。</strong></li>
</ul>
</li>
</ul>
<hr>
<hr>
<h4 id="获取通道">获取通道</h4>
<p><strong>1、Java 针对支持通道的类提供了 getChannel() 方法</strong></p>
<ul>
<li>
<p><strong>本地 IO：</strong></p>
<ul>
<li><strong>FileInputStream/FileOutputStream</strong></li>
<li><strong>RandomAccessFile</strong></li>
</ul>
</li>
<li>
<p><strong>网络IO：</strong></p>
<ul>
<li><strong>Socket</strong></li>
<li><strong>ServerSocket</strong></li>
<li><strong>DatagramSocket</strong></li>
</ul>
</li>
</ul>
<p><strong>2、在 JDK 1.7 中的 NIO.2 针对各个通道提供了静态方法 open()</strong><br>
<strong>3、在 JDK 1.7 中的 NIO.2 的 Files 工具类的 newByteChannel()</strong></p>
<hr>
<h4 id="非直接缓冲区利用通道完成文件的复制">非直接缓冲区：利用通道完成文件的复制</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    </span><br><span class="line">    FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">    FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//①获取通道</span></span><br><span class="line">    FileChannel inChannel = <span class="keyword">null</span>;</span><br><span class="line">    FileChannel outChannel = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fis = <span class="keyword">new</span> FileInputStream(<span class="string">"1.jpg"</span>);</span><br><span class="line">        fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"2.jpg"</span>);</span><br><span class="line">        </span><br><span class="line">        inChannel = fis.getChannel();</span><br><span class="line">        outChannel = fos.getChannel();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//②分配指定大小的缓冲区</span></span><br><span class="line">        ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//③将通道中的数据存入缓冲区中</span></span><br><span class="line">        <span class="keyword">while</span>(inChannel.read(buf) != -<span class="number">1</span>)&#123;</span><br><span class="line">            buf.flip(); <span class="comment">//切换读取数据的模式</span></span><br><span class="line">            <span class="comment">//④将缓冲区中的数据写入通道中</span></span><br><span class="line">            outChannel.write(buf);</span><br><span class="line">            buf.clear(); <span class="comment">//清空缓冲区</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(outChannel != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                outChannel.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(inChannel != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                inChannel.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(fos != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(fis != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">"耗费时间为："</span> + (end - start));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="直接缓冲区使用内存映射文件完成文件的复制">直接缓冲区：使用内存映射文件完成文件的复制</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    </span><br><span class="line">    FileChannel inChannel = FileChannel</span><br><span class="line">            .open(Paths.get(<span class="string">"1.jpg"</span>), StandardOpenOption.READ);</span><br><span class="line">    FileChannel outChannel = FileChannel</span><br><span class="line">            .open(Paths.get(<span class="string">"3.jpg"</span>), StandardOpenOption.WRITE, </span><br><span class="line">            StandardOpenOption.READ, StandardOpenOption.CREATE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//内存映射文件</span></span><br><span class="line">    MappedByteBuffer inMappedBuf = inChannel.map(MapMode.READ_ONLY, <span class="number">0</span>, inChannel.size());</span><br><span class="line">    MappedByteBuffer outMappedBuf = outChannel.map(MapMode.READ_WRITE, <span class="number">0</span>, inChannel.size());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//直接对缓冲区进行数据的读写操作</span></span><br><span class="line">    <span class="keyword">byte</span>[] dst = <span class="keyword">new</span> <span class="keyword">byte</span>[inMappedBuf.limit()];</span><br><span class="line">    inMappedBuf.get(dst);</span><br><span class="line">    outMappedBuf.put(dst);</span><br><span class="line">    </span><br><span class="line">    inChannel.close();</span><br><span class="line">    outChannel.close();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">"耗费时间为："</span> + (end - start));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="直接缓冲区通道之间的数据传输">直接缓冲区：通道之间的数据传输</h4>
<ul>
<li><strong>transferFrom()</strong></li>
<li><strong>transferTo()</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    FileChannel inChannel = FileChannel.open(Paths.get(<span class="string">"1.jpg"</span>), </span><br><span class="line">            StandardOpenOption.READ);</span><br><span class="line">    FileChannel outChannel = FileChannel.open(Paths.get(<span class="string">"4.jpg"</span>), </span><br><span class="line">            StandardOpenOption.WRITE, StandardOpenOption.READ, StandardOpenOption.CREATE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//inChannel.transferTo(0, inChannel.size(), outChannel);</span></span><br><span class="line">    outChannel.transferFrom(inChannel, <span class="number">0</span>, inChannel.size());</span><br><span class="line">    </span><br><span class="line">    inChannel.close();</span><br><span class="line">    outChannel.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<hr>
<h4 id="分散scatter和聚集gather">分散(Scatter)和聚集(Gather)</h4>
<p><strong>分散读取（Scattering Reads）：是指从 Channel 中读取的数据“分散”到多个 Buffer 中。</strong></p>
<ul>
<li><strong>注意：按照缓冲区的顺序，从 Channel 中读取的数据依次将Buffer 填满。</strong></li>
</ul>
<img src="https://i.loli.net/2019/05/07/5cd118ce30e05.png" alt="%8$(HR_SW(K@WSKAPK_[8OX.png" title="%8$(HR_SW(K@WSKAPK_[8OX.png">
<hr>
<p><strong>聚集写入（Gathering Writes）：是指将多个 Buffer 中的数据“聚集”到 Channel。</strong></p>
<ul>
<li><strong>注意：按照缓冲区的顺序，写入 position 和limit 之间的数据到 Channel 。</strong></li>
</ul>
<img src="https://i.loli.net/2019/05/07/5cd118e66e017.png" alt="MZ_[U)($_FPF)4]6DHM7K`2.png" title="MZ_[U)($_FPF)4]6DHM7K`2.png">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    </span><br><span class="line">    RandomAccessFile raf1 = <span class="keyword">new</span> RandomAccessFile(<span class="string">"1.txt"</span>, <span class="string">"rw"</span>);<span class="comment">//读写模式</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1. 获取通道</span></span><br><span class="line">    FileChannel channel1 = raf1.getChannel();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. 分配指定大小的缓冲区</span></span><br><span class="line">    ByteBuffer buf1 = ByteBuffer.allocate(<span class="number">100</span>);</span><br><span class="line">    ByteBuffer buf2 = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3. 分散读取</span></span><br><span class="line">    ByteBuffer[] bufs = &#123;buf1, buf2&#125;;</span><br><span class="line">    channel1.read(bufs);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (ByteBuffer byteBuffer : bufs) &#123;</span><br><span class="line">        byteBuffer.flip();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(bufs[<span class="number">0</span>].array(), <span class="number">0</span>, bufs[<span class="number">0</span>].limit()));</span><br><span class="line">    System.out.println(<span class="string">"-----------------"</span>);</span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(bufs[<span class="number">1</span>].array(), <span class="number">0</span>, bufs[<span class="number">1</span>].limit()));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4. 聚集写入</span></span><br><span class="line">    RandomAccessFile raf2 = <span class="keyword">new</span> RandomAccessFile(<span class="string">"2.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">    FileChannel channel2 = raf2.getChannel();</span><br><span class="line">    </span><br><span class="line">    channel2.write(bufs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="字符集-charbuffer">字符集 CharBuffer</h4>
<ul>
<li><strong>编码：字符串 -&gt; 字节数组</strong></li>
<li><strong>解码：字节数组 -&gt; 字符串</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    Charset cs1 = Charset.forName(<span class="string">"GBK"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取编码器</span></span><br><span class="line">    CharsetEncoder ce = cs1.newEncoder();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取解码器</span></span><br><span class="line">    CharsetDecoder cd = cs1.newDecoder();</span><br><span class="line">    </span><br><span class="line">    CharBuffer cBuf = CharBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    cBuf.put(<span class="string">"字符集：Charset"</span>);</span><br><span class="line">    cBuf.flip();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//编码</span></span><br><span class="line">    ByteBuffer bBuf = ce.encode(cBuf);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">        System.out.println(bBuf.get());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//解码</span></span><br><span class="line">    bBuf.flip();</span><br><span class="line">    CharBuffer cBuf2 = cd.decode(bBuf);</span><br><span class="line">    System.out.println(cBuf2.toString());</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">"------------------------------------------------------"</span>);</span><br><span class="line">    </span><br><span class="line">    Charset cs2 = Charset.forName(<span class="string">"UTF-8"</span>);<span class="comment">//GBG编码，UTF-8解码。乱码</span></span><br><span class="line">    bBuf.flip();</span><br><span class="line">    CharBuffer cBuf3 = cs2.decode(bBuf);</span><br><span class="line">    System.out.println(cBuf3.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<hr>
<h2 id="三-nio-的非阻塞式网络通信">三、NIO 的非阻塞式网络通信</h2>
<p><strong>阻塞</strong></p>
<ul>
<li><strong>传统的 IO 流都是阻塞式的。也就是说，当一个线程调用 read() 或 write() 时，该线程被阻塞，直到有一些数据被读取或写入，该线程在此期间不能执行其他任务。因此，在完成网络通信进行 IO 操作时，由于线程会阻塞，所以服务器端必须为每个客户端都提供一个独立的线程进行处理， 当服务器端需要处理大量客户端时，性能急剧下降。</strong></li>
</ul>
<hr>
<p><strong>非阻塞</strong></p>
<ul>
<li><strong>Java NIO 是非阻塞模式的。当线程从某通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务。线程通常将非阻塞 IO 的空闲时 间用于在其他通道上执行 IO 操作，所以单独的线程可以管理多个输入和输出通道。因此，NIO 可以让服务器端使用一个或有限几个线程来同时处理连接到服务器端的所有客户端。</strong></li>
</ul>
<hr>
<hr>
<h3 id="使用-nio-完成网络通信的三个核心">使用 NIO 完成网络通信的三个核心</h3>
<ul>
<li>
<p><strong>1、通道（Channel）：负责连接。</strong></p>
<ul>
<li><strong>java.nio.channels.Channel 接口：</strong>
<ul>
<li><strong>SelectableChannel</strong>
<ul>
<li><strong><code>SocketChannel</code></strong></li>
<li><strong><code>ServerSocketChannel</code></strong></li>
<li><strong><code>DatagramChannel</code></strong></li>
<li><strong>Pipe.SinkChannel</strong></li>
<li><strong>Pipe.SourceChannel</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>2、缓冲区（Buffer）：负责数据的存取。</strong></p>
</li>
<li>
<p><strong>3、选择器（Selector）：是 SelectableChannel 的多路复用器。用于监控 SelectableChannel 的 IO 状况。</strong></p>
</li>
</ul>
<hr>
<hr>
<h3 id="选择器selector">选择器（Selector）</h3>
<p><strong>Selector 是非阻塞 IO 的核心。</strong></p>
<p><strong>选择器（Selector）是 SelectableChannle 对象的多路复用器，Selector 可以同时监控多个 SelectableChannel 的 IO 状况。<code>利用 Selector 可使一个单独的线程管理多个 Channel。</code></strong></p>
<ul>
<li><strong>当调用 register(Selector sel, int ops)  将通道注册选择器时，选择器 对通道的监听事件，需要通过第二个参数 ops 指定。</strong></li>
<li><strong>可以监听的事件类型（可使用 SelectionKey 的四个常量表示）：</strong>
<ul>
<li><strong>读：SelectionKey.OP_READ  （1）</strong></li>
<li><strong>写：SelectionKey.OP_WRITE （4）</strong></li>
<li><strong>连接：SelectionKey.OP_CONNECT（8）</strong></li>
<li><strong>接收：SelectionKey.OP_ACCEPT （16）</strong></li>
</ul>
</li>
<li><strong>若注册时不止监听一个事件，则可以使用“位或”操作符连接。</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> interestSet = SelectionKey.OP_ACCEPT | SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure>
<img src="https://i.loli.net/2019/05/07/5cd12263f2924.png" alt="GC9U{}UD[M_C$V0B]CJ3D9R.png" title="GC9U{}UD[M_C$V0B]CJ3D9R.png">
<hr>
<hr>
<h4 id="selector-的常用方法">Selector 的常用方法</h4>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Set<selectionkey> keys()</selectionkey></td>
<td>所有的 SelectionKey 集合。代表注册在该Selector上的Channel</td>
</tr>
<tr>
<td>selectedKeys()</td>
<td>被选择的 SelectionKey 集合。返回此Selector的已选择键集</td>
</tr>
<tr>
<td>int select()</td>
<td>监控所有注册的Channel，当它们中间有需要处理的 IO 操作时， 该方法返回，并将对应得的 SelectionKey 加入被选择的 SelectionKey 集合中，该方法返回这些 Channel 的数量。</td>
</tr>
<tr>
<td>int select(long timeout)</td>
<td>可以设置超时时长的 select() 操作</td>
</tr>
<tr>
<td>int selectNow()</td>
<td>执行一个立即返回的 select() 操作，该方法不会阻塞线程</td>
</tr>
<tr>
<td>Selector wakeup()</td>
<td>使一个还未返回的 select() 方法立即返回</td>
</tr>
<tr>
<td>void close()</td>
<td>关闭该选择器</td>
</tr>
</tbody>
</table>
<hr>
<hr>
<h4 id="selectionkey">SelectionKey</h4>
<ul>
<li><strong>表示 SelectableChannel 和 Selector 之间的注册关系。每次向选择器注册通道时就会选择一个事件(选择键)。选择键包含两个表示为整数值的操作集。操作集的每一位都表示该键的通道所支持的一类可选择操作。</strong></li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>int interestOps()</td>
<td>获取感兴趣事件集合</td>
</tr>
<tr>
<td>int readyOps()</td>
<td>获取通道已经准备就绪的操作的集合</td>
</tr>
<tr>
<td>SelectableChannel channel()</td>
<td>获取注册通道</td>
</tr>
<tr>
<td>Selector selector()</td>
<td>返回选择器</td>
</tr>
<tr>
<td>boolean isReadable()</td>
<td>检测 Channal 中读事件是否就绪</td>
</tr>
<tr>
<td>boolean isWritable()</td>
<td>检测 Channal 中写事件是否就绪</td>
</tr>
<tr>
<td>boolean isConnectable()</td>
<td>检测 Channel 中连接是否就绪</td>
</tr>
<tr>
<td>boolean isAcceptable()</td>
<td>检测 Channel 中接收是否就绪</td>
</tr>
</tbody>
</table>
<hr>
<hr>
<h4 id="socketchannel-tcp网络套接字">SocketChannel TCP网络套接字</h4>
<p><strong>Java NIO中的SocketChannel是一个连接到TCP网络套接字的通道。</strong><br>
<strong>Java NIO中的 ServerSocketChannel 是一个可以监听新进来的<code>TCP</code>连接的通道，就像标准IO中的ServerSocket一样。</strong></p>
<hr>
<hr>
<h3 id="阻塞式nio-demo">阻塞式NIO Demo</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.StandardOpenOption;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBlockingNIO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 客户端</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">client</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 获取通道</span></span><br><span class="line">        SocketChannel sChannel = SocketChannel.open(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">9898</span>));</span><br><span class="line"></span><br><span class="line">        FileChannel inChannel = FileChannel.open(Paths.get(<span class="string">"1.png"</span>), StandardOpenOption.READ);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 分配指定大小的缓冲区</span></span><br><span class="line">        ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 读取本地文件，并发送到服务端</span></span><br><span class="line">        <span class="keyword">while</span> (inChannel.read(buf) != -<span class="number">1</span>) &#123;</span><br><span class="line">            buf.flip();</span><br><span class="line">            sChannel.write(buf);</span><br><span class="line">            buf.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 关闭通道</span></span><br><span class="line">        inChannel.close();</span><br><span class="line">        sChannel.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务端</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">server</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 获取通道</span></span><br><span class="line">        ServerSocketChannel ssChannel = ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line">        FileChannel outChannel = FileChannel.open(Paths.get(<span class="string">"2.png"</span>), StandardOpenOption.WRITE,</span><br><span class="line">                StandardOpenOption.CREATE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 绑定连接</span></span><br><span class="line">        ssChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9898</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 获取客户端连接的通道</span></span><br><span class="line">        SocketChannel sChannel = ssChannel.accept();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 分配指定大小的缓冲区</span></span><br><span class="line">        ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 接收客户端的数据，并保存到本地</span></span><br><span class="line">        <span class="keyword">while</span> (sChannel.read(buf) != -<span class="number">1</span>) &#123;</span><br><span class="line">            buf.flip();</span><br><span class="line">            outChannel.write(buf);</span><br><span class="line">            buf.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 关闭通道</span></span><br><span class="line">        sChannel.close();</span><br><span class="line">        outChannel.close();</span><br><span class="line">        ssChannel.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>客户端接收服务端的反馈 Demo 比较 👆</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.StandardOpenOption;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBlockingNIO2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 客户端</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">client</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SocketChannel sChannel = SocketChannel.open(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">9898</span>));</span><br><span class="line"></span><br><span class="line">        FileChannel inChannel = FileChannel.open(Paths.get(<span class="string">"1.png"</span>), StandardOpenOption.READ);</span><br><span class="line"></span><br><span class="line">        ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (inChannel.read(buf) != -<span class="number">1</span>) &#123;</span><br><span class="line">            buf.flip();</span><br><span class="line">            sChannel.write(buf);</span><br><span class="line">            buf.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sChannel.shutdownOutput();<span class="comment">//因为是阻塞模式，需要告诉服务端发送完毕</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收服务端的反馈</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len = sChannel.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            buf.flip();</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(buf.array(), <span class="number">0</span>, len));</span><br><span class="line">            buf.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        inChannel.close();</span><br><span class="line">        sChannel.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务端</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">server</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocketChannel ssChannel = ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line">        FileChannel outChannel = FileChannel.open(Paths.get(<span class="string">"2.png"</span>), StandardOpenOption.WRITE,</span><br><span class="line">                StandardOpenOption.CREATE);</span><br><span class="line"></span><br><span class="line">        ssChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9898</span>));</span><br><span class="line"></span><br><span class="line">        SocketChannel sChannel = ssChannel.accept();</span><br><span class="line"></span><br><span class="line">        ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (sChannel.read(buf) != -<span class="number">1</span>) &#123;</span><br><span class="line">            buf.flip();</span><br><span class="line">            outChannel.write(buf);</span><br><span class="line">            buf.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送反馈给客户端</span></span><br><span class="line">        buf.put(<span class="string">"服务端接收数据成功"</span>.getBytes());</span><br><span class="line">        buf.flip();</span><br><span class="line">        sChannel.write(buf);</span><br><span class="line"></span><br><span class="line">        sChannel.close();</span><br><span class="line">        outChannel.close();</span><br><span class="line">        ssChannel.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<hr>
<h3 id="非阻塞式nio-使用选择器-selector">非阻塞式NIO 使用选择器 Selector</h3>
<p><strong>切换非阻塞模式</strong></p>
<p><strong><code>Channel.configureBlocking(false);</code></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestNonBlockingNIO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 客户端</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">client</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 获取通道</span></span><br><span class="line">        SocketChannel sChannel = SocketChannel.open(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">9898</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 切换非阻塞模式</span></span><br><span class="line">        sChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 分配指定大小的缓冲区</span></span><br><span class="line">        ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 发送数据给服务端</span></span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (scan.hasNext()) &#123;</span><br><span class="line">            String str = scan.next();</span><br><span class="line">            buf.put((<span class="keyword">new</span> Date().toString() + <span class="string">"\n"</span> + str).getBytes());</span><br><span class="line">            buf.flip();</span><br><span class="line">            sChannel.write(buf);</span><br><span class="line">            buf.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 关闭通道</span></span><br><span class="line">        sChannel.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务端</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">server</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 获取通道</span></span><br><span class="line">        ServerSocketChannel ssChannel = ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 切换非阻塞模式</span></span><br><span class="line">        ssChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 绑定连接</span></span><br><span class="line">        ssChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9898</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 获取选择器</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 将通道注册到选择器上, 并且指定“监听接收事件”</span></span><br><span class="line">        ssChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 轮询式的获取选择器上已经“准备就绪”的事件</span></span><br><span class="line">        <span class="keyword">while</span> (selector.select() &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 7. 获取当前选择器中所有注册的“选择键(已就绪的监听事件)”</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                <span class="comment">// 8. 获取准备“就绪”的事件</span></span><br><span class="line">                SelectionKey sk = it.next();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 9. 判断具体是什么事件准备就绪</span></span><br><span class="line">                <span class="keyword">if</span> (sk.isAcceptable()) &#123;</span><br><span class="line">                    <span class="comment">// 10. 若“接收就绪”，获取客户端连接</span></span><br><span class="line">                    SocketChannel sChannel = ssChannel.accept();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 11. 切换非阻塞模式</span></span><br><span class="line">                    sChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 12. 将该通道注册到选择器上</span></span><br><span class="line">                    sChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sk.isReadable()) &#123;</span><br><span class="line">                    <span class="comment">// 13. 获取当前选择器上“读就绪”状态的通道</span></span><br><span class="line">                    SocketChannel sChannel = (SocketChannel) sk.channel();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 14. 读取数据</span></span><br><span class="line">                    ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">while</span> ((len = sChannel.read(buf)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        buf.flip();</span><br><span class="line">                        System.out.println(<span class="keyword">new</span> String(buf.array(), <span class="number">0</span>, len));</span><br><span class="line">                        buf.clear();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 15. 取消选择键 SelectionKey</span></span><br><span class="line">                it.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<hr>
<h3 id="datagramchannel-收发udp包的通道">DatagramChannel 收发UDP包的通道</h3>
<p><strong>Java NIO中的DatagramChannel是一个能收发<code>UDP</code>包的通道。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.DatagramChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDatagramChannel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        DatagramChannel dc = DatagramChannel.open();</span><br><span class="line"></span><br><span class="line">        dc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (scan.hasNext()) &#123;</span><br><span class="line">            String str = scan.next();</span><br><span class="line">            buf.put((<span class="keyword">new</span> Date().toString() + <span class="string">":\n"</span> + str).getBytes());</span><br><span class="line">            buf.flip();</span><br><span class="line">            dc.send(buf, <span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">9898</span>));</span><br><span class="line">            buf.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        dc.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        DatagramChannel dc = DatagramChannel.open();</span><br><span class="line"></span><br><span class="line">        dc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        dc.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9898</span>));</span><br><span class="line"></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">        dc.register(selector, SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (selector.select() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                SelectionKey sk = it.next();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (sk.isReadable()) &#123;</span><br><span class="line">                    ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">                    dc.receive(buf);</span><br><span class="line">                    buf.flip();</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> String(buf.array(), <span class="number">0</span>, buf.limit()));</span><br><span class="line">                    buf.clear();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            it.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<hr>
<h3 id="管道-pipe">管道 (Pipe)</h3>
<p><strong>Java NIO 管道是2个线程之间的单向数据连接。</strong><br>
<strong>Pipe有一个source通道和一个sink通道。数据会被写到sink通道，从source通道读取。</strong></p>
<img src="https://i.loli.net/2019/05/07/5cd1624338cba.png" alt="IP_$6G%)2KE8T$3GEU1)WKP.png" title="IP_$6G%)2KE8T$3GEU1)WKP.png">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Pipe;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPipe</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 获取管道</span></span><br><span class="line">        Pipe pipe = Pipe.open();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 将缓冲区中的数据写入管道</span></span><br><span class="line">        ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        Pipe.SinkChannel sinkChannel = pipe.sink();</span><br><span class="line">        buf.put(<span class="string">"通过单向管道发送数据"</span>.getBytes());</span><br><span class="line">        buf.flip();</span><br><span class="line">        sinkChannel.write(buf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 读取缓冲区中的数据</span></span><br><span class="line">        Pipe.SourceChannel sourceChannel = pipe.source();</span><br><span class="line">        buf.flip();</span><br><span class="line">        <span class="keyword">int</span> len = sourceChannel.read(buf);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(buf.array(), <span class="number">0</span>, len));</span><br><span class="line"></span><br><span class="line">        sourceChannel.close();</span><br><span class="line">        sinkChannel.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<hr>
<h2 id="四-path-paths-files-java-17">四、Path、Paths、Files java 1.7</h2>
<p><strong>随着 JDK 7 的发布，Java对NIO进行了极大的扩展，增强了对文件处理和文件系统特性的支持，我们称他们为 NIO.2。因为 NIO 提供的一些功能，NIO已经成为文件处理中越来越重要的部分。</strong></p>
<hr>
<h4 id="path-与-paths">Path 与 Paths</h4>
<p><strong>java.nio.file.Path 接口代表一个平台无关的平台路径，描述了目录结构中文件的位置。</strong></p>
<p><strong>Paths 提供的 get() 方法用来获取 Path 对象</strong></p>
<ul>
<li><strong>Path get(String first, String … more) 用于将多个字符串串连成路径。</strong></li>
</ul>
<p><strong>Path常用方法</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean endsWith(String path)</td>
<td>判断是否以 path 路径结束</td>
</tr>
<tr>
<td>boolean startsWith(String path)</td>
<td>判断是否以 path 路径开始</td>
</tr>
<tr>
<td>boolean isAbsolute()</td>
<td>判断是否是绝对路径</td>
</tr>
<tr>
<td>Path getFileName()</td>
<td>返回与调用 Path 对象关联的文件名</td>
</tr>
<tr>
<td>Path getName(int idx)</td>
<td>返回的指定索引位置 idx 的路径名称</td>
</tr>
<tr>
<td>int getNameCount()</td>
<td>返回Path 根目录后面元素的数量</td>
</tr>
<tr>
<td>Path getParent()</td>
<td>返回Path对象包含整个路径，不包含Path 对象指定的文件路径</td>
</tr>
<tr>
<td>Path getRoot()</td>
<td>返回调用 Path 对象的根路径</td>
</tr>
<tr>
<td>Path resolve(Path p)</td>
<td>将相对路径解析为绝对路径</td>
</tr>
<tr>
<td>Path toAbsolutePath()</td>
<td>作为绝对路径返回调用 Path 对象</td>
</tr>
<tr>
<td>String toString()</td>
<td>返回调用 Path 对象的字符串表示形式</td>
</tr>
</tbody>
</table>
<hr>
<h4 id="files">Files</h4>
<p><strong>java.nio.file.Files 用于操作文件或目录的工具类。</strong></p>
<p><strong>Files常用方法</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Path copy(Path src, Path dest, CopyOption … how)</td>
<td>文件的复制</td>
</tr>
<tr>
<td>Path createDirectory(Path path, FileAttribute&lt;?&gt; … attr)</td>
<td>创建一个目录</td>
</tr>
<tr>
<td>Path createFile(Path path, FileAttribute&lt;?&gt; … arr)</td>
<td>创建一个文件</td>
</tr>
<tr>
<td>void delete(Path path)</td>
<td>删除一个文件</td>
</tr>
<tr>
<td>Path move(Path src, Path dest, CopyOption…how)</td>
<td>将 src 移动到 dest 位置</td>
</tr>
<tr>
<td>long size(Path path)</td>
<td>返回 path 指定文件的大小</td>
</tr>
</tbody>
</table>
<hr>
<p><strong>Files常用方法：用于判断</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean exists(Path path, LinkOption … opts)</td>
<td>判断文件是否存在</td>
</tr>
<tr>
<td>boolean isDirectory(Path path, LinkOption … opts)</td>
<td>判断是否是目录</td>
</tr>
<tr>
<td>boolean isExecutable(Path path)</td>
<td>判断是否是可执行文件</td>
</tr>
<tr>
<td>boolean isHidden(Path path)</td>
<td>判断是否是隐藏文件</td>
</tr>
<tr>
<td>boolean isReadable(Path path)</td>
<td>判断文件是否可读</td>
</tr>
<tr>
<td>boolean isWritable(Path path)</td>
<td>判断文件是否可写</td>
</tr>
<tr>
<td>boolean notExists(Path path, LinkOption … opts)</td>
<td>判断文件是否不存在</td>
</tr>
<tr>
<td>public static &lt;A extends BasicFileAttributes&gt; A readAttributes(Path path,Class&lt;A&gt; type,LinkOption… options)</td>
<td>获取与 path 指定的文件相关联的属性。</td>
</tr>
</tbody>
</table>
<hr>
<p><strong>Files常用方法：用于操作内容</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>SeekableByteChannel newByteChannel(Path path, OpenOption…how)</td>
<td>获取与指定文件的连接， how 指定打开方式。</td>
</tr>
<tr>
<td>DirectoryStream newDirectoryStream(Path path)</td>
<td>打开 path 指定的目录</td>
</tr>
<tr>
<td>InputStream newInputStream(Path path, OpenOption…how)</td>
<td>获取 InputStream 对象</td>
</tr>
<tr>
<td>OutputStream newOutputStream(Path path, OpenOption…how)</td>
<td>获取 OutputStream 对象</td>
</tr>
</tbody>
</table>
<h1 id="感谢阅读">感谢阅读</h1>

                

                <hr>
                <!-- Pager -->
                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/article/Ajax/" data-toggle="tooltip" data-placement="top" title="Ajax (Asynchronous)">&larr; Previous Post</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/article/Java8新特性/" data-toggle="tooltip" data-placement="top" title="Java 8 新特性">Next Post &rarr;</a>
                        </li>
                    
                </ul>

                <br>

                <!--打赏-->
                
                    <div class="reward">
                        <div class="reward-button">赏 <span class="reward-code"> 
                            <span class="alipay-code"> <img class="alipay-img" src="http://ww1.sinaimg.cn/large/006vWPzFly1g0o77ru34uj30dz0drdhv.jpg"><b>支付宝打赏</b></span> 
                            <span class="wechat-code"> <img class="wechat-img" src="http://ww1.sinaimg.cn/large/006vWPzFly1g0o740lhb9j30rb0ov77z.jpg"><b>微信打赏</b> </span>
                            </span></div>
                        <p class="reward-notice">赞赏一下</p>
                    </div>
                
                <!--打赏-->

                <br>
                <!--分享-->
                
                <!--分享-->
                <br>                       
                
                <!-- require APlayer -->
                

                <!-- duoshuo Share start -->
                
                <!-- 多说 Share end-->

                <!-- 多说评论框 start -->
                
                <!-- 多说评论框 end -->

                <!-- disqus comment start -->
                
                <!-- disqus comment end -->

                

            </div>
            
            <!-- Tabe of Content -->
            <!-- Table of Contents -->

  
    <style>
      span.toc-nav-number{
        display: none
      }
    </style>
  
    
      <aside id="sidebar">
        <div id="toc" class="toc-article">
        <strong class="toc-title">Contents</strong>
        
          <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#一-java-nio-简介"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">&#x4E00;&#x3001;Java NIO &#x7B80;&#x4ECB;</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#二-通道channel与-缓冲区buffer"><span class="toc-nav-number">2.</span> <span class="toc-nav-text">&#x4E8C;&#x3001;&#x901A;&#x9053;&#xFF08;Channel&#xFF09;&#x4E0E; &#x7F13;&#x51B2;&#x533A;&#xFF08;Buffer&#xFF09;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#1-缓冲区buffer"><span class="toc-nav-number">2.1.</span> <span class="toc-nav-text">1&#x3001;&#x7F13;&#x51B2;&#x533A;&#xFF08;Buffer&#xFF09;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#缓冲区存取数据的核心方法"><span class="toc-nav-number">2.1.1.</span> <span class="toc-nav-text">&#x7F13;&#x51B2;&#x533A;&#x5B58;&#x53D6;&#x6570;&#x636E;&#x7684;&#x6838;&#x5FC3;&#x65B9;&#x6CD5;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#缓冲区中的五个核心属性"><span class="toc-nav-number">2.1.2.</span> <span class="toc-nav-text">&#x7F13;&#x51B2;&#x533A;&#x4E2D;&#x7684;&#x4E94;&#x4E2A;&#x6838;&#x5FC3;&#x5C5E;&#x6027;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#buffer-的常用方法"><span class="toc-nav-number">2.1.3.</span> <span class="toc-nav-text">Buffer &#x7684;&#x5E38;&#x7528;&#x65B9;&#x6CD5;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#直接缓冲区与非直接缓冲区"><span class="toc-nav-number">2.1.4.</span> <span class="toc-nav-text">&#x76F4;&#x63A5;&#x7F13;&#x51B2;&#x533A;&#x4E0E;&#x975E;&#x76F4;&#x63A5;&#x7F13;&#x51B2;&#x533A;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#2-通道channel"><span class="toc-nav-number">2.2.</span> <span class="toc-nav-text">2&#x3001;&#x901A;&#x9053;&#xFF08;Channel&#xFF09;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#获取通道"><span class="toc-nav-number">2.2.1.</span> <span class="toc-nav-text">&#x83B7;&#x53D6;&#x901A;&#x9053;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#非直接缓冲区利用通道完成文件的复制"><span class="toc-nav-number">2.2.2.</span> <span class="toc-nav-text">&#x975E;&#x76F4;&#x63A5;&#x7F13;&#x51B2;&#x533A;&#xFF1A;&#x5229;&#x7528;&#x901A;&#x9053;&#x5B8C;&#x6210;&#x6587;&#x4EF6;&#x7684;&#x590D;&#x5236;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#直接缓冲区使用内存映射文件完成文件的复制"><span class="toc-nav-number">2.2.3.</span> <span class="toc-nav-text">&#x76F4;&#x63A5;&#x7F13;&#x51B2;&#x533A;&#xFF1A;&#x4F7F;&#x7528;&#x5185;&#x5B58;&#x6620;&#x5C04;&#x6587;&#x4EF6;&#x5B8C;&#x6210;&#x6587;&#x4EF6;&#x7684;&#x590D;&#x5236;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#直接缓冲区通道之间的数据传输"><span class="toc-nav-number">2.2.4.</span> <span class="toc-nav-text">&#x76F4;&#x63A5;&#x7F13;&#x51B2;&#x533A;&#xFF1A;&#x901A;&#x9053;&#x4E4B;&#x95F4;&#x7684;&#x6570;&#x636E;&#x4F20;&#x8F93;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#分散scatter和聚集gather"><span class="toc-nav-number">2.2.5.</span> <span class="toc-nav-text">&#x5206;&#x6563;(Scatter)&#x548C;&#x805A;&#x96C6;(Gather)</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#字符集-charbuffer"><span class="toc-nav-number">2.2.6.</span> <span class="toc-nav-text">&#x5B57;&#x7B26;&#x96C6; CharBuffer</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#三-nio-的非阻塞式网络通信"><span class="toc-nav-number">3.</span> <span class="toc-nav-text">&#x4E09;&#x3001;NIO &#x7684;&#x975E;&#x963B;&#x585E;&#x5F0F;&#x7F51;&#x7EDC;&#x901A;&#x4FE1;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#使用-nio-完成网络通信的三个核心"><span class="toc-nav-number">3.1.</span> <span class="toc-nav-text">&#x4F7F;&#x7528; NIO &#x5B8C;&#x6210;&#x7F51;&#x7EDC;&#x901A;&#x4FE1;&#x7684;&#x4E09;&#x4E2A;&#x6838;&#x5FC3;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#选择器selector"><span class="toc-nav-number">3.2.</span> <span class="toc-nav-text">&#x9009;&#x62E9;&#x5668;&#xFF08;Selector&#xFF09;</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#selector-的常用方法"><span class="toc-nav-number">3.2.1.</span> <span class="toc-nav-text">Selector &#x7684;&#x5E38;&#x7528;&#x65B9;&#x6CD5;</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#selectionkey"><span class="toc-nav-number">3.2.2.</span> <span class="toc-nav-text">SelectionKey</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#socketchannel-tcp网络套接字"><span class="toc-nav-number">3.2.3.</span> <span class="toc-nav-text">SocketChannel TCP&#x7F51;&#x7EDC;&#x5957;&#x63A5;&#x5B57;</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#阻塞式nio-demo"><span class="toc-nav-number">3.3.</span> <span class="toc-nav-text">&#x963B;&#x585E;&#x5F0F;NIO Demo</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#非阻塞式nio-使用选择器-selector"><span class="toc-nav-number">3.4.</span> <span class="toc-nav-text">&#x975E;&#x963B;&#x585E;&#x5F0F;NIO &#x4F7F;&#x7528;&#x9009;&#x62E9;&#x5668; Selector</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#datagramchannel-收发udp包的通道"><span class="toc-nav-number">3.5.</span> <span class="toc-nav-text">DatagramChannel &#x6536;&#x53D1;UDP&#x5305;&#x7684;&#x901A;&#x9053;</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#管道-pipe"><span class="toc-nav-number">3.6.</span> <span class="toc-nav-text">&#x7BA1;&#x9053; (Pipe)</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#四-path-paths-files-java-17"><span class="toc-nav-number">4.</span> <span class="toc-nav-text">&#x56DB;&#x3001;Path&#x3001;Paths&#x3001;Files java 1.7</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#path-与-paths"><span class="toc-nav-number">4.0.1.</span> <span class="toc-nav-text">Path &#x4E0E; Paths</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#files"><span class="toc-nav-number">4.0.2.</span> <span class="toc-nav-text">Files</span></a></li></ol></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#感谢阅读"><span class="toc-nav-number"></span> <span class="toc-nav-text">&#x611F;&#x8C22;&#x9605;&#x8BFB;</span></a>
        
        </div>
      </aside>
    

                
            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#NIO" title="NIO">NIO</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">

                    
                        <li><a href="https://yexua.github.io/" target="_blank">大佬</a></li>
                    
                        <li><a href="https://snailclimb.gitee.io/javaguide/#/" target="_blank">JavaGuide</a></li>
                    
                        <li><a href="http://cyc2018.gitee.io/cs-notes/#/notes/%E5%89%91%E6%8C%87%20Offer%20%E9%A2%98%E8%A7%A3%20-%20%E7%9B%AE%E5%BD%951" target="_blank">剑指Offer</a></li>
                    
                        <li><a href="http://cyc2018.gitee.io/cs-notes/#/" target="_blank">技术面试必备基础知识</a></li>
                    
                </ul>
                
            </div>
        </div>
    </div>
</article>








<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'left',
          icon: 'ℬ'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                

                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/GitHub-yuteng">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; 于腾 2019 
                    <br>
                    Theme by <a href="http://beantech.org">BeanTech</a> 
                    <span style="display: inline-block; margin: 0 5px;">
                        <i class="fa fa-heart"></i>
                    </span> 
                    re-Ported by <a href="http://www.huweihuang.com">胡伟煌</a> | 
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="91px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=huweihuang&repo=hexo-theme-huweihuang&type=star&count=true" >
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("https://github-yuteng.github.io/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->


<script>
    // dynamic User by Hux
    var _gaId = 'UA-XXXXXXXX-X';
    var _gaDomain = 'yoursite';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>




<!-- Baidu Tongji -->

<script>
    // dynamic User by Hux
    var _baId = 'xxx';

    // Originial
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?" + _baId;
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
</script>






	<a id="rocket" href="#top" class=""></a>
	<script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
    <script type="text/javascript" src="/js/toc.js?v=1.0.0" async=""></script>
<!-- Image to hack wechat -->
<img src="https://github-yuteng.github.io/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
